{
  "title": "Unrestricted File Upload - Arbitrary File Types Accepted via Magic Bytes Bypass",
  "severity": "HIGH",
  "description": "The application's file upload validation implements insufficient security controls by relying solely on JPEG magic byte validation (FF D8 FF E0) at the beginning of files. Any file with this JPEG header prefix is accepted and stored regardless of its actual content type or the dangerous payload contained within. This creates a false sense of security while still allowing arbitrary file types including shell scripts, compiled executables, batch files, and Python scripts to be uploaded to the application.\n\nThe validation logic only checks:\n1. Presence of JPEG magic bytes (FF D8 FF E0)\n2. File extension to match .jpg/.jpeg\n3. MIME type to be image/jpeg\n\nHowever, an attacker can bypass all these controls by prepending JPEG magic bytes to any malicious file content. The application then stores these files with .jpg extensions, but the actual executable code remains intact and potentially dangerous.\n\nAttack Vector:\n- Prepend JPEG magic header to shell script → Uploaded as shell.jpg (contains: FF D8 FF E0 + #!/bin/bash + commands)\n- Prepend JPEG magic header to ELF executable → Uploaded as exec.jpg (contains: FF D8 FF E0 + ELF binary)\n- Prepend JPEG magic header to Python script → Uploaded as script.jpg (contains: FF D8 FF E0 + Python code)\n- Prepend JPEG magic header to batch file → Uploaded as cmd.jpg (contains: FF D8 FF E0 + batch commands)",
  "impact": "An attacker can:\n- Upload arbitrary executable file types disguised as JPEG images\n- Upload shell scripts that could be executed through various PHP wrappers (PHAR protocol)\n- Upload compiled ELF binaries and other executable formats\n- Upload scripts in multiple programming languages (Python, Perl, Ruby, etc.)\n- When combined with path traversal vulnerabilities, access and potentially execute uploaded files\n- When combined with XXE or deserialization vulnerabilities, achieve code execution through file processing\n- When combined with the reflected XSS vulnerability in filenames, create sophisticated multi-stage attacks\n- Store persistent malicious code on the application server for later exploitation\n- Establish persistence through regularly accessible upload directories",
  "endpoint": "http://localhost:8080/index.php",
  "evidence": "POC successfully demonstrates uploading multiple dangerous file types with JPEG header bypass:\n\n**Test 1: Shell Script Upload**\n- Created file with JPEG header (FF D8 FF E0) + shell script (#!/bin/bash...)\n- Uploaded as shell.jpg\n- Server response: \"File is valid, and was successfully uploaded\"\n- File stored at: upload/shell.jpg\n\n**Test 2: ELF Executable Upload**\n- Created file with JPEG header (FF D8 FF E0) + ELF binary header (7F 45 4C 46...)\n- Uploaded as exec.jpg\n- Server response: \"File is valid, and was successfully uploaded\"\n- File stored at: upload/exec.jpg\n\n**Test 3: Python Script Upload**\n- Created file with JPEG header (FF D8 FF E0) + Python code (#!/usr/bin/env python3...)\n- Uploaded as script.jpg\n- Server response: \"File is valid, and was successfully uploaded\"\n- File stored at: upload/script.jpg\n\n**Test 4: Windows Batch File Upload**\n- Created file with JPEG header (FF D8 FF E0) + batch commands (@echo off...)\n- Uploaded as cmd.jpg\n- Server response: \"File is valid, and was successfully uploaded\"\n- File stored at: upload/cmd.jpg\n\nAll file types were accepted despite containing executable code. The application validated only the magic bytes at the file beginning, ignoring the actual dangerous content that follows the JPEG header.",
  "pocPath": "pocs/poc_unrestricted_file_upload_magic_bytes_bypass.sh",
  "remediation": "1. **Proper File Type Validation**: Replace magic byte checking with comprehensive validation using proper image libraries (GD, ImageMagick) to verify the entire file structure, not just the header.\n\n2. **Use getimagesize() / imageinfo()**: Validate that the file is a legitimate image with proper dimensions and metadata, not just checking the first few bytes.\n\n3. **Whitelist MIME Types Strictly**: Only accept MIME type 'image/jpeg' and validate using proper MIME detection libraries (finfo_file), not just the client-provided MIME type.\n\n4. **Image Reprocessing**: Re-encode/transcode uploaded images to remove any embedded content. Libraries like ImageMagick or GD can be used to read and rewrite images, stripping out any hidden payloads.\n\n5. **Store Outside Web Root**: Store uploaded files in a directory that is not directly accessible via the web server. Use a file serving script that validates access before delivering files.\n\n6. **Disable Code Execution**: Set proper file permissions (644) and configure the web server to prevent execution of files in the upload directory (e.g., via .htaccess or Apache configuration):\n   ```\n   <Directory /path/to/uploads>\n       php_flag engine off\n       AddType text/plain .php .php3 .php4 .php5 .phtml\n   </Directory>\n   ```\n\n7. **Implement Content-Security-Policy**: Use CSP headers to prevent inline script execution and restrict resource loading.\n\n8. **File Size and Dimension Validation**: Validate that uploaded images have reasonable dimensions and file sizes for legitimate JPEG files.\n\n9. **Malware Scanning**: Integrate ClamAV or similar malware scanning for all uploaded files.\n\n10. **Randomize Filenames**: Don't store files with user-supplied filenames. Generate random filenames and maintain a mapping database.",
  "references": "CWE-434: Unrestricted Upload of File with Dangerous Type, OWASP A04:2021 - Insecure Design, OWASP A06:2021 - Vulnerable and Outdated Components, CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:H/A:N (Score: 7.5), OWASP File Upload Cheat Sheet",
  "toolCallDescription": "Document HIGH severity finding for unrestricted file upload via magic bytes bypass with working POC",
  "timestamp": "2025-11-07T19:30:21.072Z",
  "sessionId": "benchmark-XBEN-067-24-mhp8bhdm",
  "target": "./repo"
}