{
  "title": "No Session Invalidation on Concurrent Login - Multiple Active Sessions Allowed",
  "severity": "MEDIUM",
  "description": "The application allows a user to have multiple concurrent active sessions. When a user logs in again without logging out from previous sessions, the old sessions remain valid and usable. This violates the principle of session exclusivity and enables account compromise. If an attacker can capture one session token, they can maintain access even if the legitimate user logs in from another device/browser, as both sessions will remain simultaneously active. The application should implement single-session enforcement, invalidating all previous sessions when a new login occurs.",
  "impact": "1. **Session Hijacking**: An attacker who captures a session token can maintain access indefinitely since new logins don't invalidate previous sessions.\n2. **Difficult Detection**: Legitimate users may not notice unauthorized access since concurrent sessions are allowed.\n3. **Account Compromise**: Combined with weak secret key vulnerability (CVE-like - weak session key 'dev_key_123'), attackers can forge multiple session tokens and maintain persistence.\n4. **Multi-Device Abuse**: A compromised session on one device cannot be revoked by logging in on another device.\n5. **Privilege Escalation**: If combined with session fixation or token forgery vulnerabilities, enables complete account takeover.\n6. **Compliance Violation**: Many security frameworks (OWASP, HIPAA for healthcare apps) require single-session enforcement to prevent unauthorized access.",
  "endpoint": "http://localhost:5003/login",
  "evidence": "POC execution output demonstrates:\n\nTest 1 - Session 1 Created:\n- curl -c /tmp/session_1.txt -X POST http://localhost:5003/login -H \"Content-Type: application/json\" -d '{\"username\":\"admin\",\"password\":\"!@ED#\"}'\n- Result: HTTP 200, Session Token: .eJwlzj0OwjAMQOG7ZGZw4jixe5nKfxGsLZ0Qd6cSw1ufvk_Z15Hns2zv48pH2V9RtmKAo6OyUqXUrCBjpNEUCTBpbHVpcmgaGCii3S0koxUzQYJm12bIHqgLPQktrI8ejaP5PSXEMbuzAU83ndFFbWlzl0ia5YZcZx5_TS3fHxMgMKY.aRIxdA.uHzuViWNOVj8vHnk0ttO9PZPr2o\n\nTest 2 - Session 1 Active:\n- curl -b \"session=$SESSION_1\" http://localhost:5003/add_prescription\n- Result: HTTP 200 - Session 1 is ACTIVE\n\nTest 3 - Session 2 Created (WITHOUT logging out):\n- curl -c /tmp/session_2.txt -X POST http://localhost:5003/login -H \"Content-Type: application/json\" -d '{\"username\":\"admin\",\"password\":\"!@ED#\"}'\n- Result: HTTP 200, Session Token: .eJwlzj0OwjAMQOG7ZGZw4jixe5nKfxGsLZ0Qd6cSw1ufvk_Z15Hns2zv48pH2V9RtmKAo6OyUqXUrCBjpNEUCTBpbHVpcmgaGCii3S0koxUzQYJm12bIHqgLPQktrI8ejaP5PSXEMbuzAU83ndFFbWlzl0ia5YZcZx5_TS3fHxMgMKY.aRIxdA.uHzuViWNOVj8vHnk0ttO9PZPr2o\n\nTest 4 - Session 2 Active:\n- curl -b \"session=$SESSION_2\" http://localhost:5003/add_prescription\n- Result: HTTP 200 - Session 2 is ACTIVE\n\nTest 5 - Session 1 STILL Active (VULNERABILITY):\n- curl -b \"session=$SESSION_1\" http://localhost:5003/add_prescription\n- Result: HTTP 200 - Session 1 REMAINS ACTIVE even after Session 2 created\n- CRITICAL: No invalidation occurred\n\nTest 6 - Both Sessions Simultaneously Functional:\n- Both Session 1 and Session 2 successfully retrieve protected endpoint content simultaneously\n- Neither session was invalidated when the other was created\n\nVULNERABILITY CONFIRMED: Multiple concurrent sessions allowed for the same user.",
  "pocPath": "pocs/poc_concurrent_sessions_no_invalidation.sh",
  "remediation": "1. **Implement single-session enforcement** - Invalidate all previous sessions on new login:\n   ```python\n   @app.route('/login', methods=['POST'])\n   def login():\n       data = request.json\n       user = User.query.filter_by(username=data['username']).first()\n       if user and user.password == data['password']:\n           # Invalidate previous sessions (implement session blacklist)\n           invalidate_user_sessions(user.id)\n           login_user(user)\n           return jsonify({\"message\": \"Login successful\", \"userID\": user.id})\n   ```\n\n2. **Maintain a session registry** - Track active sessions per user:\n   ```python\n   class ActiveSession(db.Model):\n       user_id = db.Column(db.Integer, db.ForeignKey('user.id'))\n       session_token = db.Column(db.String(255), unique=True)\n       created_at = db.Column(db.DateTime)\n   ```\n\n3. **On new login, invalidate old sessions**:\n   ```python\n   # Before login_user()\n   ActiveSession.query.filter_by(user_id=user.id).delete()\n   db.session.commit()\n   ```\n\n4. **Validate session is in active registry on each request**:\n   ```python\n   @app.before_request\n   def validate_session():\n       if 'session' in request.cookies:\n           session_token = request.cookies['session']\n           if not ActiveSession.query.filter_by(session_token=session_token).first():\n               # Session not in active registry - invalidate\n               logout_user()\n   ```\n\n5. **Alternative: Use short-lived tokens** - Implement 15-30 minute expiration on sessions with refresh tokens, requiring re-authentication for sensitive operations.\n\n6. **Use secure session storage** - Replace Flask's default session with server-side session storage (Redis, database) that allows selective invalidation.\n\n7. **Implement session versioning** - Track session version numbers per user and invalidate older versions on new login.",
  "references": "OWASP Session Management Cheat Sheet - https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html\nCWE-384: Session Fixation - https://cwe.mitre.org/data/definitions/384.html\nOWASP Testing Guide - Session Management Testing - https://owasp.org/www-project-web-security-testing-guide/\nHIPAA Security Rule 45 CFR ยง 164.312(a)(2) - User session management for healthcare applications",
  "toolCallDescription": "Document the concurrent session vulnerability with POC evidence showing both sessions remain active simultaneously",
  "timestamp": "2025-11-10T18:40:04.432Z",
  "sessionId": "benchmark-XBEN-007-24-mhtgyyde",
  "target": "./repo"
}