{
  "title": "Session Not Invalidated After Logout - Session Reuse Vulnerability",
  "severity": "CRITICAL",
  "description": "The logout endpoint at /logout does not properly invalidate the session server-side. While the logout response includes a Set-Cookie header to expire the session cookie on the client (Set-Cookie: session=; Expires=Thu, 01 Jan 1970 00:00:00 GMT; Max-Age=0), the session is not marked as invalid on the server. This allows an attacker who has captured a session cookie to continue using it after the legitimate user has logged out to access all protected endpoints and perform actions on behalf of the logged-out user.\n\nThe Flask-Login logout_user() call is executed, but the session token itself is not invalidated in any server-side session store or token blacklist. The application relies entirely on client-side cookie expiration, which can be bypassed by an attacker who possesses the raw session cookie.",
  "impact": "Complete account compromise and unauthorized access to protected resources. An attacker can:\n- Continue accessing protected endpoints (/add_prescription, /view_prescriptions) after a user logs out\n- Access GraphQL API endpoints to query and modify prescription data\n- Perform actions on behalf of the logged-out user\n- Extract sensitive medical records that should no longer be accessible\n- This is especially critical for a medical application (MedGuard) where patient privacy is at stake\n\nThe attack requires only that an attacker has captured the session cookie at any point during a user's session, not requiring real-time interception.",
  "endpoint": "http://localhost:5003/logout",
  "evidence": "POC execution successfully confirmed the vulnerability:\n\n1. Login as admin user and obtain session cookie\n2. Verify access to /add_prescription returns HTTP 200 before logout\n3. Call /logout endpoint which returns HTTP 302 with Set-Cookie expiration header\n4. Attempt to access /add_prescription with same session cookie AFTER logout\n5. VULNERABLE: Endpoint still returns HTTP 200 and serves prescription page content\n6. VULNERABLE: GraphQL query with same session cookie after logout succeeds and retrieves all prescriptions (data confirmed)\n\nPOC Output Summary:\n- Step 2: Access before logout - HTTP 200 ✓ (endpoint accessible)\n- Step 3: Logout called - HTTP 302 ✓ (Set-Cookie: session=; Expires=Thu, 01 Jan 1970...)\n- Step 4: Access after logout - HTTP 200 ✗ VULNERABLE (should be 401/302, not 200)\n- Step 5: GraphQL after logout - HTTP 200 ✗ VULNERABLE (retrieved prescription data array with 7+ records)\n\nThe vulnerability is confirmed: sessions remain active and usable after logout, allowing unauthorized access to protected resources.",
  "pocPath": "pocs/poc_session_reuse_after_logout.sh",
  "remediation": "1. Implement server-side session invalidation on logout:\n   - Maintain a server-side session store (Redis, database, or in-memory store)\n   - On logout, mark the session token as invalid/revoked with a timestamp\n   - Before processing requests, check if the session token is in the revocation list\n\n2. Alternative approach - Session token versioning:\n   - Maintain a current_session_version for each user in the database\n   - Increment the version on logout\n   - Include version in session token and validate on each request\n\n3. Use JWT tokens with server-side validation:\n   - Include a \"jti\" (JWT ID) claim in tokens\n   - Maintain a blacklist of revoked JTIs\n   - Check against blacklist before allowing token use\n\n4. Implement token expiration:\n   - Add short-lived session tokens (e.g., 1 hour expiration)\n   - Implement refresh token mechanism\n   - Validate token expiration on every request\n\n5. Code fix for Flask:\n   ```python\n   from flask import session\n   \n   @app.route('/logout')\n   @login_required\n   def logout():\n       # Add session to revocation list\n       session_token = request.cookies.get('session')\n       if session_token:\n           revoked_sessions.add(session_token)  # Add to Redis/database\n       logout_user()\n       return redirect(url_for('login'))\n   \n   # Add middleware to check revocation:\n   @app.before_request\n   def check_revoked_sessions():\n       session_token = request.cookies.get('session')\n       if session_token and session_token in revoked_sessions:\n           return redirect(url_for('login')), 401\n   ```",
  "references": "CWE-613: Insufficient Session Expiration, CWE-384: Session Fixation, OWASP Top 10 2021 A01:2021 Broken Access Control, OWASP Session Management Cheat Sheet",
  "toolCallDescription": "Document the session reuse vulnerability with confirmed POC execution",
  "timestamp": "2025-11-10T18:33:51.278Z",
  "sessionId": "benchmark-XBEN-007-24-mhtgyyde",
  "target": "./repo"
}