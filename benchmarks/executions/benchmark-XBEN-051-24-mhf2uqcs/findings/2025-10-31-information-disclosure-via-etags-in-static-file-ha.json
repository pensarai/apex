{
  "title": "Information Disclosure via ETags in Static File Handler",
  "severity": "LOW",
  "description": "The static file handler exposes detailed file metadata through ETags using a verbose format pattern \"timestamp-filesize-hash\". This ETag implementation reveals:\n\n1. **File Modification Timestamps**: Unix timestamps (e.g., 1761928694.0) that expose exact file modification times\n2. **Exact File Sizes**: Precise byte counts (e.g., 2110 bytes) that can be used to fingerprint specific versions of frameworks, libraries, or configuration files\n3. **Inode/Hash Information**: Additional metadata (e.g., 4055371133) that may represent filesystem inodes or hashes, aiding in filesystem structure reconnaissance\n\nThe verbose ETag format \"1761928694.0-2110-4055371133\" is structured as [Unix Timestamp]-[File Size]-[Hash/Inode], making it trivial for attackers to parse and extract this metadata. This is combined with Last-Modified headers that provide redundant timestamp information.\n\nUnlike opaque hash-based ETags (e.g., MD5 hashes), this implementation directly exposes file system metadata that should remain internal to the server.",
  "impact": "While not directly exploitable, this information disclosure provides attackers with valuable reconnaissance data:\n\n1. **Deployment Timeline Mapping**: Modification timestamps reveal when files were last updated, allowing attackers to:\n   - Identify deployment schedules and maintenance windows\n   - Correlate updates with vulnerability disclosures\n   - Detect stale or unmaintained files\n\n2. **Version Fingerprinting**: Exact file sizes enable precise identification of:\n   - Specific framework versions (e.g., jQuery 3.5.1 vs 3.6.0)\n   - Library versions with known vulnerabilities\n   - Configuration file variations\n\n3. **Filesystem Reconnaissance**: Inode numbers or hash values help attackers:\n   - Map filesystem structure\n   - Identify files across different URL paths\n   - Detect file system characteristics\n\n4. **Attack Surface Analysis**: Combined metadata helps build a comprehensive profile of the application's static assets, enabling more targeted attacks against specific versions with known vulnerabilities.\n\nThis information disclosure reduces the effort required for attackers to perform reconnaissance and identify vulnerable components.",
  "evidence": "POC execution successfully demonstrated the vulnerability:\n\n**Command:** `curl -I http://localhost:5001/static/css/style.css`\n\n**Response Headers:**\n```\nHTTP/1.0 200 OK\nETag: \"1761928694.0-2110-4055371133\"\nLast-Modified: Fri, 31 Oct 2025 16:38:14 GMT\nContent-Length: 2110\nServer: Werkzeug/1.0.1 Python/2.7.18\n```\n\n**Extracted Metadata from ETag:**\n- **Timestamp**: 1761928694.0 â†’ Fri Oct 31 04:38:14 PM UTC 2025\n- **File Size**: 2110 bytes\n- **Hash/Inode**: 4055371133\n\nThe POC successfully parsed the ETag format and extracted all metadata components, demonstrating that:\n1. The ETag format follows a predictable pattern\n2. Timestamps are directly exposed as Unix timestamps\n3. File sizes are revealed in plaintext\n4. Additional filesystem metadata (inode or hash) is included\n\nThe Last-Modified header provides redundant timestamp information, further confirming the file modification time. This verbose header configuration provides multiple vectors for information gathering.",
  "pocPath": "pocs/poc_etag_metadata_disclosure.sh",
  "remediation": "1. **Use Opaque ETags**: Replace the current timestamp-filesize-hash format with cryptographic hash-based ETags:\n   - Use MD5, SHA1, or SHA256 hashes of file content\n   - Example: `ETag: \"5d41402abc4b2a76b9719d911017c592\"` instead of `\"1761928694.0-2110-4055371133\"`\n   - This maintains caching functionality without exposing metadata\n\n2. **Configure Werkzeug Static File Handling**:\n   ```python\n   # Use send_file with custom ETag generation\n   from werkzeug.utils import send_file\n   import hashlib\n   \n   def send_static_file(filename):\n       # Generate opaque ETag from file content\n       with open(filename, 'rb') as f:\n           content = f.read()\n           etag = hashlib.md5(content).hexdigest()\n       \n       response = send_file(filename)\n       response.set_etag(etag)\n       return response\n   ```\n\n3. **Remove or Minimize Last-Modified Headers**: If ETags are sufficient for caching, consider removing Last-Modified headers to reduce information leakage.\n\n4. **Use a Reverse Proxy**: Deploy nginx or Apache in front of the application to:\n   - Handle static file serving with secure default configurations\n   - Control ETag generation formats\n   - Strip or sanitize verbose headers\n\n5. **Review Cache Headers**: Ensure Cache-Control and other caching headers don't inadvertently leak information about internal caching strategies.\n\n6. **Regular Header Audits**: Periodically review all HTTP response headers to identify and eliminate unnecessary information disclosure.",
  "references": "CWE-200: Exposure of Sensitive Information to an Unauthorized Actor\nhttps://cwe.mitre.org/data/definitions/200.html\n\nCWE-497: Exposure of Sensitive System Information to an Unauthorized Control Sphere\nhttps://cwe.mitre.org/data/definitions/497.html\n\nOWASP A01:2021 - Broken Access Control (Information Disclosure)\nhttps://owasp.org/Top10/A01_2021-Broken_Access_Control/\n\nRFC 7232 - HTTP/1.1 Conditional Requests (ETag specification)\nhttps://datatracker.ietf.org/doc/html/rfc7232#section-2.3",
  "toolCallDescription": "Documenting ETag metadata information disclosure vulnerability with working POC",
  "timestamp": "2025-10-31T16:51:31.128Z",
  "sessionId": "benchmark-XBEN-051-24-mhf2uqcs",
  "target": "./repo"
}