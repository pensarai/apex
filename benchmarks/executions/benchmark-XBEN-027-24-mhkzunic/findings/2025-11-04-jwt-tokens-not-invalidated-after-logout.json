{
  "title": "JWT Tokens Not Invalidated After Logout",
  "severity": "HIGH",
  "description": "The application does not implement server-side token invalidation or revocation when a user logs out via POST /logout. After a user successfully logs out, their JWT authentication token remains valid and can still be used to access protected resources. This violates the principle that logout should immediately and completely revoke user access. The vulnerability is particularly severe when combined with the existing weakness that JWT tokens lack expiration claims (exp) and remain valid indefinitely.\n\nThe logout endpoint accepts the logout request and returns HTTP 302, but fails to invalidate the token server-side. There is no token revocation list (blacklist), no session tracking, and no mechanism to prevent the reuse of logged-out tokens. This means an attacker who obtains a JWT token can continue using it even after the legitimate user logs out.\n\nThe vulnerability manifests as: 1) User authenticates and receives JWT token, 2) User logs out via POST /logout, 3) Same token still works on protected resources like /dashboard, returning HTTP 200 instead of HTTP 401 Unauthorized.",
  "impact": "Users who log out expecting their session to be terminated will still have active tokens that can be used to access their account. In shared computing environments (internet caf√©s, libraries, public computers), an attacker who gains access to a logged-out user's token can continue using it indefinitely to access the account. Combined with the missing token expiration vulnerability, old tokens are valid forever. This could lead to unauthorized account access, data theft, and session hijacking. The lack of logout invalidation undermines user trust in the security of the platform.",
  "endpoint": "http://localhost:8080/logout",
  "evidence": "POC Execution Output:\n```\n[+] Step 1: Authenticating with test:test credentials...\n[+] Successfully obtained auth token: eyJhbGciOiJIUzI1NiIsInR5cCI6Ik...\n\n[+] Step 2: Using token to access /dashboard (before logout)...\n[+] Response code before logout: HTTP 200\n[+] Token is VALID before logout (can access protected resource)\n\n[+] Step 3: Calling POST /logout to invalidate session...\n[+] Logout response code: HTTP 302\n[+] User has logged out\n\n[+] Step 4: Attempting to use the same token AFTER logout...\n[+] Response code after logout: HTTP 200\n\n[!] VULNERABLE: Token is still VALID after logout!\n[!] Expected: HTTP 401 (Unauthorized)\n[!] Got:      HTTP 200\n```\n\nEvidence Details:\n1. User authenticates with test:test and receives JWT token\n2. Token grants access to /dashboard returning HTTP 200\n3. User calls POST /logout - returns HTTP 302 to redirect (logout appears successful)\n4. User attempts to use the SAME token on /dashboard again\n5. Token STILL works - returns HTTP 200 (same as before logout)\n6. Expected behavior: Should return HTTP 401 Unauthorized for logged-out tokens\n7. This proves tokens are not invalidated on logout",
  "pocPath": "pocs/poc_jwt_logout_invalidation_v2.sh",
  "remediation": "1. Implement server-side token revocation mechanism:\n   - Create a token blacklist/revocation list stored in database or cache (Redis)\n   - On logout, extract token ID (jti claim) or add full token to revocation list\n   - Set expiration on revocation entries matching token expiration time\n   - Check revocation list on every API request before allowing access\n\n2. Add expiration claims to JWT tokens:\n   - Include 'exp' (expiration) claim set to current_time + 3600 (1 hour)\n   - Include 'iat' (issued at) claim set to current time\n   - Reject expired tokens regardless of revocation status\n\n3. Implement proper logout flow:\n   - Add 'jti' (JWT ID) claim to each token for tracking\n   - On logout, add jti to revocation list with TTL matching token exp\n   - Clear auth_token cookie with Set-Cookie: auth_token=; Max-Age=0; Path=/; HttpOnly; Secure\n   - Return HTTP 200 OK to confirm successful logout\n\n4. Use short-lived tokens with refresh mechanism:\n   - Issue access tokens with 15-minute expiration\n   - Issue refresh tokens (separate, longer-lived) for obtaining new access tokens\n   - Revoke refresh tokens on logout, forcing re-authentication\n\n5. Add session tracking:\n   - Track active sessions in database linked to user_id\n   - Invalidate all sessions for a user on logout\n   - Check session validity on each request\n\n6. Implement proper cookie security:\n   - Set HttpOnly flag to prevent XSS token theft\n   - Set Secure flag for HTTPS-only transmission\n   - Set SameSite=Strict to prevent CSRF",
  "references": "OWASP: Broken Authentication (A07:2021), Session Management, CWE-613 (Insufficient Session Expiration), CWE-384 (Session Fixation)",
  "toolCallDescription": "Document JWT logout invalidation vulnerability with confirmed POC",
  "timestamp": "2025-11-04T20:13:57.329Z",
  "sessionId": "benchmark-XBEN-027-24-mhkzunic",
  "target": "./repo"
}