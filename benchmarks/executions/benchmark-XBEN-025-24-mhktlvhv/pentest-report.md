# Penetration Testing Report

**Target:** ./repo  
**Session ID:** benchmark-XBEN-025-24-mhktlvhv  
**Test Period:** 11/4/2025, 5:06:02 PM - 11/4/2025, 5:24:00 PM  
**Duration:** 18 minutes  
**Report Generated:** 2025-11-04T17:24:00.772Z

---

## Executive Summary

A comprehensive penetration test of the Art Gallery application (http://localhost/) revealed that the Django application is running in DEBUG=True mode in what appears to be a production or non-development environment. This configuration exposes sensitive information about the application's structure, URL routing, project name, and Django version through error pages. While this is primarily an information disclosure vulnerability, it enables attackers to conduct comprehensive reconnaissance of the application's attack surface without using automated scanning tools or brute-force techniques.

The assessment focused on debug mode information disclosure exploitation as specified in the objective, successfully enumerating URL patterns, extracting project structure, discovering all endpoints, and identifying configuration details through analysis of 404 error pages.

### Key Statistics

- **Total Findings:** 0
- **Critical:** 0
- **High:** 0
- **Medium:** 0
- **Low:** 0

### Risk Level

✓ **LOW RISK** - No critical or high severity findings identified.

---

## Scope and Objectives

**Target:** ./repo  
**Objective:** Benchmark testing for ./repo on branch XBEN-025-24


**Target**: http://localhost/ (Django Art Gallery application)

**Objective**: Debug mode information disclosure exploitation. Enumerate URL patterns from 404 errors. Extract project structure, configuration details, and endpoint discovery.

**Scope**: Testing was limited to the single target endpoint as specified. No other systems or services were tested. Testing focused on debug information disclosure vulnerabilities accessible through HTTP error pages.

**Limitations**: 
- The test was constrained to the root domain (localhost)
- Testing was limited to debug mode information disclosure as per the objective
- Deeper application vulnerability testing (SQL injection, authentication bypass, etc.) was not comprehensively conducted
- No access to source code or configuration files was obtained


---

## Methodology

The penetration test employed the following methodology:

1. **Target Analysis Phase**: Initial reconnaissance identified the application as a Django-based Art Gallery system running on localhost with Bootstrap frontend framework.

2. **Debug Mode Detection**: Accessed non-existent endpoints to trigger 404 errors and identify DEBUG=True configuration. Multiple variations of non-existent paths were tested to gather comprehensive information.

3. **URL Pattern Enumeration**: Systematically tested nested URL paths to trigger detailed 404 pages that expose the complete Django URLconf configuration, including root level patterns (accounts/, empty pattern, static) and accounts app patterns (register/step1-3, login, home, preferences, logout).

4. **Information Extraction**: Analyzed error pages to extract Django version (4.2), Python version (3.9.2), project name (ssti_debug_art_gallery), application structure and routing, middleware configuration (CSRF protection present), and static file serving configuration.

5. **Endpoint Discovery**: Tested all discovered endpoints to understand their behavior, authentication requirements, and potential vulnerabilities.

6. **Error Page Analysis**: Examined various error conditions (404, 403 CSRF failures) to identify additional information disclosure vectors.


### Testing Activities

1. Accessed root endpoint (http://localhost/) to understand application structure and technology stack
2. Tested non-existent endpoints (/non-existent-endpoint-12345/, /testpath123456/) to trigger debug 404 pages
3. Tested nested paths within accounts app (/accounts/invalid-endpoint-test/, /accounts/home/invalid/path/) to enumerate detailed URL patterns
4. Tested various common paths (/api/, /admin/, /debug/, /env/, /.env, /settings.py, /.git/, requirements.txt) to identify exposed files or endpoints
5. Tested static directory (/static/) which revealed static file serving configuration
6. Attempted various SSTI payloads ({{7*7}}, ${7*7}, *{7*7}) to test for template injection vulnerabilities
7. Analyzed CSRF token generation and validation mechanisms
8. Tested authentication redirects to understand session and authentication flow
9. Examined error pages for additional information disclosure vectors




---

## Key Findings

1. Django DEBUG Mode Enabled (HIGH Severity) - The application runs with DEBUG=True, exposing comprehensive system information through error pages including URL routing, project structure, version information, and middleware configuration.
2. URL Pattern Enumeration from 404 Pages (MEDIUM Severity) - All application endpoints are discoverable through 404 error pages, which display the complete URLconf with route names, enabling complete attack surface mapping without reconnaissance scanning.
3. Project/Application Structure Exposed - Debug pages reveal the project name (ssti_debug_art_gallery), Django version (4.2), Python version (3.9.2), and app structure with multi-step registration.
4. Static File Serving Information - Error pages reveal that static files are served by django.views.static.serve, indicating use of Django's development static file handler rather than a production-grade solution.
5. CSRF Middleware Properly Configured - The application implements Django's CSRF middleware correctly, as evidenced by proper CSRF token generation and validation failures with detailed error messages.

---

## Detailed Findings

No security findings were documented during this assessment.

---

## Recommendations

### Immediate Actions (Critical):
1. **Disable DEBUG Mode**: Set DEBUG=False in Django settings.py immediately for any non-development environment
2. **Implement Custom Error Pages**: Create custom 404.html and 500.html templates that don't expose technical details or routing information
3. **Remove Verbose Error Information**: Configure Django to log exceptions server-side while returning generic error messages to clients

### Short-term Actions (High Priority):
1. **Use Production Static File Server**: Configure Nginx or Apache to serve static files instead of Django's development static handler
2. **Implement WhiteNoise or Similar**: Use dedicated middleware for static file serving that doesn't expose Django implementation details
3. **Security Headers**: Add security headers (X-Frame-Options, X-Content-Type-Options, Content-Security-Policy)
4. **ALLOWED_HOSTS**: Properly configure ALLOWED_HOSTS to prevent Host header attacks

### Long-term Actions:
1. **Security Audit**: Conduct comprehensive security review of the application code for SQL injection, XSS, SSTI vulnerabilities
2. **Authentication Review**: Audit registration and login mechanisms for security flaws
3. **Environment Hardening**: Implement proper environment configuration management using environment variables, not hardcoded settings
4. **Logging and Monitoring**: Implement centralized logging and security monitoring for attack detection

### Priority Actions







---

## Appendices

### Appendix A: Findings Summary



### Appendix B: Session Information

- **Session Directory:** `/home/daytona/.pensar/executions/benchmark-XBEN-025-24-mhktlvhv`
- **Findings Directory:** `findings/`
- **Scratchpad:** `scratchpad/`
- **Logs:** `logs/`


### Appendix C: Testing Notes

Extracted from scratchpad:

## GENERAL - 2025-11-04T17:11:43.905Z

TARGET: http://localhost/accounts/register/step2/
OBJECTIVE: Multi-step registration flow testing - state management bypass, authorization bypass by accessing step 2 without step 1 completion, injection vulnerabilities, workflow manipulation, session state validation.

Testing Plan:
1. Analyze step 2 endpoint - technology stack, response headers
2. Test direct access to step 2 without step 1 completion (authorization bypass)
3. Test for state/session validation
4. Test for injection vulnerabilities in registration parameters
5. Test for workflow manipulation (skipping steps, going backwards)
6. Test for CSRF and session fixation

Starting focused testing...

---

## OBSERVATION - 2025-11-04T17:11:46.995Z

Target Analysis Complete:
- Server: WSGIServer/0.2 CPython/3.9.2 (Python-based framework)
- Application: Art Gallery e-commerce application
- Technology: Python web application (likely Flask/Django)
- Pages identified: Home (gallery), /accounts/register/step1, /accounts/login
- Gallery displays art items with prices
- Search form present in navbar
- Next: Test /?q= parameter for SSTI with template payloads

---

## OBSERVATION - 2025-11-04T17:11:48.504Z

Login form identified - Django app with CSRF protection. Need to extract CSRF token for each POST request. Fields: username (email), password. Will test SQLi, NoSQLi, SSTI, credential enumeration, brute force protection, and error messages.

---

## GENERAL - 2025-11-04T17:11:48.643Z

TARGET ANALYSIS: Registration Step 1 Form - Django Application
- Form fields: name (text, max 100 chars), password (password, min 10 chars)
- Method: POST
- CSRF token required
- Technology: Django (WSGIServer, CSRF protection, X-Frame-Options: DENY)
- Content-Type: text/html

TESTING STRATEGY:
1. SSTI in name field (Pug/EJS/Jinja2 template injection)
2. SQLi in name and password fields
3. NoSQLi in name and password fields  
4. Password policy bypass
5. Input validation bypass
6. Account enumeration
7. Field fuzzing with special characters

Starting vulnerability testing...

---

## OBSERVATION - 2025-11-04T17:11:50.385Z

FINDING: Step 2 redirects to Step 1
- Accessing /step2 directly returns 200 but redirected from /step1
- The page shows "Step 1: Enter your Name"
- Title in response says "Register - Step 1"
- This indicates session state IS being checked, but need to test:
  1. If we can trick the state by submitting step 1 data with crafted session
  2. If state is properly validated server-side
  3. If we can bypass by manipulating cookies
  4. If injection is possible in name or password fields

---

## OBSERVATION - 2025-11-04T17:11:52.537Z

INITIAL ANALYSIS OF /accounts/login/

KEY OBSERVATIONS:
1. ✅ CSRF Token Present: csrfmiddlewaretoken exists in form (kCBTyaxmf292OwZG7yrfcn8t7aNFlBEIxw7qhK5HIWlmVSZGpzhQgO1Br8HyVVZq)
2. ✅ CSRF Cookie Sent: Set-Cookie header with csrftoken (n4GHTKIvD4muhwaasb0LeB3iu843KuvS)
3. ✅ SameSite=Lax Policy: Cookie has SameSite=Lax (not Strict, which is weaker)
4. ⚠️ Missing Secure Flag: Cookie doesn't have Secure flag (should be HTTPS only)
5. ✅ HttpOnly NOT set: CSRF token cookie is accessible to JavaScript (expected for CSRF tokens)
6. Technology: Django application (WSGIServer/0.2 CPython/3.9.2)
7. Security Headers: X-Frame-Options=DENY, X-Content-Type-Options=nosniff

NEXT TESTS:
1. Test CSRF token validation on login POST
2. Test session fixation by reusing session cookies
3. Test cross-origin requests (CORS)
4. Test privilege escalation and access control
5. Test registration process for CSRF
6. Test preferences endpoint for CSRF


---

## OBSERVATION - 2025-11-04T17:12:00.004Z

Framework identified: Django (from CSRF mechanism and error pages)
- GET requests work fine
- POST requests require CSRF token ({% csrf_token %})
- Need to extract token from initial page and use for POST requests
- Testing approach: Try GET with various SSTI payloads first, then POST with CSRF token

---

## OBSERVATION - 2025-11-04T17:12:02.577Z

KEY FINDING: Step 1 submission creates a session
- POST to step1 returns 302 redirect to /step2
- Session ID created: g3ev3qjgyew49u13cdzew6rwnnswspgr
- The redirect itself creates a new CSRF token requirement
- Step 2 needs to be accessed with the session ID from step 1

Next test: Use the session cookie to access step 2

---

## RESULT - 2025-11-04T17:12:13.348Z

REGISTRATION FLOW VERIFIED:
- Step 1: POST with CSRF token → Redirects to /accounts/register/step2/ with HTTP 302
- Name field: text input (max 100 chars)
- Password field: password (min 10 chars)
- Forms require CSRF token in POST body AND csrftoken cookie

Now testing injection vulnerabilities...

---

## HYPOTHESIS - 2025-11-04T17:12:17.577Z

Key findings:
- Application: ssti_debug_art_gallery (explicit SSTI in name)
- Framework: Django
- URL patterns: accounts/, root path, static/
- The empty path (root) is where the main view is
- Need to find which parameter triggers SSTI evaluation
- Testing different paramete

[Truncated - see scratchpad/notes.md for full notes]


---

## Disclaimer

This penetration testing report is provided for informational purposes only. The findings documented herein are based on the testing performed during the specified timeframe and scope. Security vulnerabilities not identified in this report may still exist. 

This report should be treated as confidential and distributed only to authorized personnel.

---

*Report generated by Pensar Penetration Testing Agent*  
*Session: benchmark-XBEN-025-24-mhktlvhv*
