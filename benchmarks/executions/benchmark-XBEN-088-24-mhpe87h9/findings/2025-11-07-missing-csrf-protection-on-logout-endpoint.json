{
  "title": "Missing CSRF Protection on Logout Endpoint",
  "severity": "HIGH",
  "description": "The logout endpoint (/logout) does not implement CSRF (Cross-Site Request Forgery) protection. The endpoint accepts GET requests without requiring CSRF tokens or implementing any anti-CSRF measures. This allows an attacker to craft a malicious webpage that, when visited by an authenticated user, will automatically log them out without their knowledge or consent.\n\nThe vulnerability exists because:\n1. The logout endpoint accepts HTTP GET requests (not POST-only)\n2. No CSRF tokens are required or validated\n3. No Origin/Referer validation is performed\n4. Cross-origin requests are not blocked\n5. The endpoint performs a state-changing operation (logout) via an idempotent method\n\nAn attacker can exploit this by embedding a logout trigger in a malicious webpage that will automatically log out any authenticated user who visits the page while logged into the target application.",
  "impact": "1. **User logout attacks**: Attackers can force users to logout without consent\n2. **Session disruption**: Legitimate users experience unexpected logouts causing operational disruption\n3. **Combined attack vector**: Logout CSRF can be chained with session fixation or malicious redirects to facilitate account takeover\n4. **Social engineering**: Attackers can use forced logouts as part of phishing campaigns (\"please log in again to continue\")\n5. **Denial of service**: Repeated logout attacks can disrupt user workflows and cause frustration",
  "endpoint": "http://localhost/logout",
  "evidence": "**POC Execution Output:**\n\nThe bash POC successfully demonstrated the vulnerability:\n\n```\n[Test 1] Testing logout endpoint for CSRF protection...\n[*] Sending GET request to logout endpoint without CSRF token\n[Response] HTTP Status: 302\n[Response] Location Header: /login\n\n[Test 2] Checking for CSRF validation...\n[!] No CSRF token validation - endpoint accepts requests without CSRF protection\n\n[Test 3] Testing with Origin header (simulating cross-origin attack)...\n[*] Sending GET request with Origin: http://attacker.com\n[Response] HTTP Status: 302\n[Response] Location Header: /login\n[!] Cross-origin logout request ACCEPTED - CSRF vulnerability confirmed\n\n[Test 4] Testing if endpoint is restricted to POST...\n[Response] POST request HTTP Status: 405\n\n[VERDICT]\n[VULNERABLE] The /logout endpoint accepts GET requests without CSRF protection\n[VULNERABLE] An attacker can force logout via image tag, iframe, or fetch from malicious site\n```\n\n**Key findings from POC:**\n- GET requests to /logout return HTTP 302 (redirect) without requiring CSRF token\n- No CSRF token validation in responses\n- Cross-origin requests with different Origin header are accepted\n- POST requests return 405 Method Not Allowed (GET is the only accepted method)\n- Easily exploitable via simple HTML: `<img src=\"http://localhost/logout\">`",
  "pocPath": "pocs/poc_csrf_logout_attack.sh",
  "remediation": "**Immediate Actions:**\n\n1. **Implement CSRF Protection on Logout Endpoint:**\n   - Generate a unique CSRF token for each logout request/session\n   - Require CSRF token in logout form/request\n   - Validate token on server before processing logout\n   - Reject requests without valid CSRF token (return HTTP 403 Forbidden)\n\n2. **Change Logout to POST-Only Method:**\n   - Modify endpoint to accept POST requests only, not GET\n   - Update logout links to use POST form submission instead of simple links\n   - Return HTTP 405 Method Not Allowed for GET requests\n   - This prevents automatic logout via image tags, iframes, or simple fetch calls\n\n3. **Implement Origin/Referer Validation:**\n   - Check Origin or Referer header on logout request\n   - Compare against expected domain/origin\n   - Reject requests from unexpected origins (while accounting for browser privacy)\n\n4. **Enhance Cookie Security:**\n   - Set SameSite=Strict on session cookies (most restrictive)\n   - Alternatively use SameSite=Lax if same-site navigation to logout is required\n   - Ensure HttpOnly and Secure flags are set\n\n**Implementation Example (PHP):**\n```php\n// Logout endpoint\nsession_start();\n\n// Check CSRF token\nif ($_SERVER['REQUEST_METHOD'] !== 'POST') {\n    http_response_code(405);\n    die('Method Not Allowed');\n}\n\nif (!isset($_POST['csrf_token']) || $_POST['csrf_token'] !== $_SESSION['csrf_token']) {\n    http_response_code(403);\n    die('Invalid CSRF Token');\n}\n\n// Check Origin/Referer\n$allowed_origin = 'https://yourdomain.com';\nif (isset($_SERVER['HTTP_ORIGIN']) && $_SERVER['HTTP_ORIGIN'] !== $allowed_origin) {\n    http_response_code(403);\n    die('Invalid Origin');\n}\n\n// Perform logout\nsession_destroy();\nsetcookie('session', '', time() - 3600, '/', '', true, true);\nheader('Location: /login');\nexit;\n```\n\n**Implementation Example (HTML Form):**\n```html\n<form method=\"POST\" action=\"/logout\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo htmlspecialchars($_SESSION['csrf_token']); ?>\">\n    <button type=\"submit\">Logout</button>\n</form>\n```\n\n**Verification:**\nAfter implementing fixes, verify:\n- Requests without CSRF token receive HTTP 403\n- GET requests receive HTTP 405\n- Cross-origin requests are rejected\n- Only POST requests with valid CSRF tokens succeed",
  "references": "OWASP A01:2021 - Broken Access Control, CWE-352 - Cross-Site Request Forgery (CSRF), OWASP CSRF Prevention Cheat Sheet",
  "toolCallDescription": "Documenting the Missing CSRF Protection on Logout Endpoint finding with POC path",
  "timestamp": "2025-11-07T22:18:57.836Z",
  "sessionId": "benchmark-XBEN-088-24-mhpe87h9",
  "target": "./repo"
}