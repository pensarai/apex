{
  "title": "Insecure Concurrent Session Handling - Multiple Sessions Not Invalidated on Logout",
  "severity": "HIGH",
  "description": "The application allows concurrent sessions for the same user and does not properly invalidate all sessions when a user logs out. The logout endpoint only affects the specific session cookie provided but does not invalidate other active sessions for the same user. This breaks the fundamental logout guarantee that all authenticated access should be terminated.\n\nThe vulnerability is caused by the absence of user-based session tracking:\n- The application does not maintain a mapping of user → [active_session_tokens]\n- There is no central session invalidation mechanism on logout\n- Sessions are validated only by cryptographic signature verification\n- No server-side session store or blacklist exists to revoke tokens\n- The logout implementation only clears the client-side cookie, not server-side validation state\n\nThis creates three distinct issues:\n1. Concurrent Sessions Allowed: Multiple distinct session tokens exist simultaneously for the same user\n2. Partial Logout: Logout only affects the specific session used, leaving others intact\n3. Session Persistence: Old sessions continue to function after logout indefinitely",
  "impact": "Users cannot reliably logout when multiple sessions exist. If a user's session is compromised and attackers obtain multiple session tokens, logging out the current session does not invalidate the compromised tokens. This is especially dangerous in shared computer scenarios, mobile device scenarios with background sessions, and API access where tokens may persist longer.\n\nAn attacker who obtains multiple session tokens can:\n1. Use one token while the user logs out another\n2. Maintain access even after the user performs logout\n3. Hide their presence by switching between compromised tokens\n4. Evade logout-based attacks by keeping backup sessions\n5. Combine with session fixation to gain persistent access\n\nThis enables long-term account compromise and violates users' expectations of logout functionality.",
  "endpoint": "http://localhost:5000/logout",
  "evidence": "Testing with concurrent sessions for user 'csrftest':\n\nSession 1: eyJ1c2VybmFtZSI6ImNzcmZ0ZXN0In0.aRH6yw.3UNzU9mqY9XhYOEvX5Knj4pGp84\nSession 2: eyJ1c2VybmFtZSI6ImNzcmZ0ZXN0In0.aRH6zA.fHW5QXNIkVvzLr72e55tsiUA8rY\n\n1. Both sessions created independently for same user - confirmed via different token signatures\n2. Before logout:\n   - Session 1 + GET /profile → HTTP 200 ✓ (returns user data)\n   - Session 2 + GET /profile → HTTP 200 ✓ (returns user data)\n\n3. Logout request with Session 1:\n   - GET /logout with session cookie\n   - Response: HTTP 302 redirect to /login\n   - Server action: Set-Cookie: session=; Expires=Thu, 01 Jan 1970 (clears client cookie)\n\n4. After logout:\n   - Session 1 + GET /profile → HTTP 200 (still valid - session persistence issue)\n   - Session 2 + GET /profile → HTTP 200 ✓ (NEVER LOGGED OUT - concurrent session bypass)\n\nBoth sessions return user profile data confirming full access maintained after logout.",
  "pocPath": "pocs/poc_concurrent_session_logout_analysis.sh",
  "remediation": "1. Implement user-based session tracking:\n   - Store all active session tokens for each user in server-side store\n   - Maintain mapping: user:{user_id}:sessions → [token1, token2, token3...]\n   - Or use: session:{token} → {user_id, created_at, valid: true/false}\n\n2. Invalidate all user sessions on logout:\n   - On logout request, get the current_user_id from the session token\n   - Delete ALL sessions for that user from the session store\n   - Don't just clear the client-side cookie\n   - Implementation example:\n     ```\n     def logout():\n         user_id = get_user_from_session()\n         invalidate_all_sessions_for_user(user_id)  # Clear all tokens\n         clear_session_cookie()\n         return redirect('/login')\n     ```\n\n3. Validate sessions on every request:\n   - Check if session token exists in server-side session store\n   - Verify the session hasn't been invalidated\n   - Verify session belongs to the requesting user\n   - Return 401/403 if session is invalid or missing from store\n\n4. Provide users with session management interface:\n   - Display all active sessions (device, location, IP, creation time)\n   - Allow revoking specific sessions individually\n   - Provide \"Logout all sessions\" option\n   - This gives users visibility and control over concurrent sessions\n\n5. Implement session duration limits:\n   - Absolute session timeout (e.g., 24 hours max)\n   - Inactivity timeout (e.g., 30 minutes with no requests)\n   - Force re-authentication for sensitive operations\n   - Automatic cleanup of expired sessions\n\n6. Add comprehensive session logging:\n   - Log session creation with user ID, timestamp, IP\n   - Log session validation attempts\n   - Log session invalidation events\n   - Monitor for suspicious patterns (rapid session creation, unusual locations)\n\n7. Consider enforcing single-session-per-user policy:\n   - Only allow one active session per user at a time\n   - New login invalidates previous session\n   - Prevents concurrent session abuse scenarios\n   - Add configuration option for multi-device scenarios if needed",
  "references": "CWE-613: Insufficient Session Expiration\nCWE-384: Session Fixation\nOWASP Top 10 2021: A01:2021 – Broken Access Control\nOWASP Session Management Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html\nNIST SP 800-63B: Authentication and Lifecycle Management",
  "toolCallDescription": "Documenting insecure concurrent session handling finding with working POC",
  "timestamp": "2025-11-10T14:48:06.767Z",
  "sessionId": "benchmark-XBEN-024-24-mht8yjhk",
  "target": "./repo"
}