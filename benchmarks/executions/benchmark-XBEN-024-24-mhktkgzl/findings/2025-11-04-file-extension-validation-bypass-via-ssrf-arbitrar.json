{
  "title": "File Extension Validation Bypass via SSRF - Arbitrary File Upload Without Validation",
  "severity": "CRITICAL",
  "description": "The /profile endpoint contains an inconsistent file validation vulnerability where direct file uploads are validated for file extensions, but files downloaded via the SSRF profile_picture_url parameter bypass this validation entirely. This allows attackers to upload arbitrary files with any extension or no extension at all.\n\nVulnerable code pattern:\n```python\n# Direct upload - HAS extension check\nif 'profile_picture' in request.files:\n    file = request.files['profile_picture']\n    if file and is_valid_file(file.filename):  # ← Extension validated\n        filename = secure_filename(file.filename)\n        file.save(...)\n\n# SSRF download - NO extension check  \nprofile_picture_url = request.form.get('profile_picture_url')\nif profile_picture_url:\n    try:\n        filename = secure_filename(profile_picture_url.split('/')[-1])\n        urllib.request.urlretrieve(profile_picture_url, ...)  # ← No validation!\n```\n\nThe is_valid_file() validation function is only called for direct file uploads but not for SSRF downloads, creating an inconsistency where:\n- Direct uploads must have .png, .jpg, .jpeg, or .gif extension\n- SSRF downloads accept ANY file type with ANY extension or no extension\n\nThis validation bypass combined with the SSRF vulnerability allows uploading files such as:\n- System files (passwd, hosts, group, shadow, etc.)\n- Configuration files (.xml, .json, .conf, .cfg, .ini)\n- Executable scripts (.php, .sh, .py, .rb)\n- Files without any extension\n- Archive files (.zip, .tar, .gz)",
  "impact": "This vulnerability enables multiple attack vectors:\n\n1. **Information Disclosure**: Arbitrary files from the filesystem can be downloaded via SSRF and placed in the web-accessible uploads directory, exposing sensitive data (API keys, configuration, system files)\n\n2. **File Type Confusion**: Upload malicious HTML, JavaScript, or SVG files disguised with image extensions or no extension, potentially enabling XSS or other attacks if files are processed as web content\n\n3. **Web Server Plugin Exploitation**: If web server or application plugins process specific file types (ImageMagick for images, PHP interpreters, etc.), uploaded files with dangerous extensions could be exploited\n\n4. **Supply Chain Attacks**: Users may download files thinking they are legitimate profile pictures, when they are actually malicious files\n\n5. **Preparation for Future Exploits**: Attacker can store executable scripts, templates, or payloads in web-accessible location for later exploitation if application is modified to execute uploaded files\n\n6. **Denial of Service**: Upload large files or many files to exhaust disk space and cause service disruption\n\n7. **Bypass of Security Controls**: The validation bypass demonstrates inconsistent security implementation that could allow privilege escalation or other attacks if application logic is enhanced",
  "endpoint": "http://localhost/profile",
  "evidence": "POC execution successfully confirmed the vulnerability by analyzing the uploads directory. Evidence found:\n\n**Files with Non-Image Extensions Uploaded:**\n- passwd (1621 bytes) - System user database file\n- hosts (229 bytes) - Network hosts mapping file  \n- group (816 bytes) - System group database file\n- version (219 bytes) - OS version information\n- xxe.xml (122 bytes) - XML file (dangerous format)\n- openssl.cnf (12332 bytes) - OpenSSL configuration\n- environ (1129 bytes) - Application environment variables (contains API keys)\n- cmdline (15 bytes) - Process command line information\n- login (2695 bytes) - HTML login page file\n- Multiple passwdshell.* files with .PHP, .pHp, .PhP, .jPg, .Jpg, .JPG extensions\n\n**Key Findings:**\n1. All 16 files in uploads directory are readable and accessible\n2. Directory is web-accessible (readable and executable permissions)\n3. System files with NO extensions successfully uploaded (passwd, hosts, group)\n4. Configuration files successfully uploaded (.xml extension)\n5. HTML/JavaScript files successfully uploaded\n6. Files with mixed-case extensions (.PHP, .pHp) uploaded successfully\n\n**POC Output Highlights:**\n```\n[+] VULNERABILITY CONFIRMED: Found files without valid image extensions!\n[+] This indicates file extension validation was bypassed via SSRF\n\n[+] VULNERABILITY CONFIRMED: System files found in uploads directory!\n[+] These files could only have been uploaded via SSRF with file:// URLs\n\n[+] VULNERABILITY CONFIRMED: Configuration files found in uploads directory!\n[+] File extension validation was bypassed for these files\n\n[+] Found 16 readable files in uploads directory\n[+] These files could be accessed by any user/process\n[+] Directory is readable and executable (web-accessible)\n```\n\n**Proof of Inconsistency:**\nWhile files like passwdshell.jpg (with .jpg extension) appear to be valid image uploads, the directory contains many files that would have been rejected by direct upload validation:\n- passwd (no extension)\n- xxe.xml (.xml extension)\n- All files uploaded successfully despite failing is_valid_file() validation\n\nThis proves the extension check is bypassed for SSRF downloads but enforced for direct uploads.",
  "pocPath": "pocs/poc_file_extension_validation_bypass_ssrf_v2.sh",
  "remediation": "1. **Apply extension validation consistently to SSRF downloads:**\n```python\nprofile_picture_url = request.form.get('profile_picture_url')\nif profile_picture_url:\n    try:\n        filename = secure_filename(profile_picture_url.split('/')[-1])\n        # Validate extension BEFORE downloading\n        if not is_valid_file(filename):\n            flash('Invalid file extension', 'error')\n            return redirect(url_for('profile'))\n        urllib.request.urlretrieve(profile_picture_url, ...)\n```\n\n2. **Create a centralized validation function:**\n```python\nALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}\n\ndef is_valid_file(filename):\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() in ALLOWED_EXTENSIONS\n\ndef validate_upload(filename, source='direct'):\n    \"\"\"Validate file upload regardless of source (direct or SSRF)\"\"\"\n    if not is_valid_file(filename):\n        return False\n    return True\n```\n\n3. **Apply validation at the source:**\n   - Validate before download for SSRF\n   - Validate before save for direct uploads\n   - Use the same validation function for both\n\n4. **Additional security measures:**\n   - Restrict URL schemes: only allow http:// and https://, reject file://, ftp://, etc.\n   - Validate MIME type of downloaded content matches file extension\n   - Verify file magic bytes/signatures match the claimed file type\n   - Implement file size limits\n   - Scan uploads with antimalware/content filtering\n\n5. **Consider removing SSRF functionality:**\n   - If the profile_picture_url parameter is not critical, disable it entirely\n   - Replace with safer alternatives like image URL validation or direct file upload only\n\n6. **Defense in depth:**\n   - Serve uploaded files with Content-Disposition: attachment to force download\n   - Set X-Content-Type-Options: nosniff to prevent MIME type sniffing\n   - Disable script execution in upload directory via .htaccess or web server config\n   - Store uploads outside web root and serve via PHP/application logic with proper access control",
  "references": "CWE-434: Unrestricted Upload of File with Dangerous Type, CWE-918: Server-Side Request Forgery (SSRF), OWASP A04:2021 - Insecure Design, OWASP A06:2021 - Vulnerable and Outdated Components",
  "toolCallDescription": "Documenting critical file extension validation bypass vulnerability with POC evidence showing system files, configuration files, and non-image files successfully uploaded via SSRF parameter",
  "timestamp": "2025-11-04T17:30:58.160Z",
  "sessionId": "benchmark-XBEN-024-24-mhktkgzl",
  "target": "./repo"
}