{
  "title": "Missing Type Validation on Term Parameter - Accepts Decimal Values Without Proper Handling",
  "severity": "MEDIUM",
  "description": "The amortization calculator endpoint fails to properly validate the 'term' parameter as an integer type. When decimal values are provided (e.g., term=5.5), the application returns an HTTP 500 Internal Server Error instead of handling it gracefully with proper validation and error messages. This indicates missing input type validation and poor error handling architecture. While the application accepts negative/zero values with HTTP 200 (business logic validation gap), it rejects decimal values with HTTP 500 (type validation failure with poor error handling). The application should either accept decimals and round appropriately, or reject them with an HTTP 400 Bad Request error and a descriptive validation message.",
  "impact": "1. Poor user experience: Cryptic 500 error instead of clear validation feedback\n2. Potential denial of service: Malformed inputs could crash/overload the application\n3. Information disclosure risk: 500 errors may expose stack traces revealing application internals in production\n4. Inconsistent validation: Negative/zero values accepted (200 OK) but decimals rejected (500 error) creates unpredictable behavior\n5. API reliability issues: Makes the endpoint unreliable for third-party integrations due to inconsistent error handling\n6. Security through obscurity violation: 500 errors are cryptic rather than informative, hindering debugging and proper API usage",
  "endpoint": "http://localhost/amortization",
  "evidence": "POC execution confirmed the vulnerability through multiple test cases:\n\nTEST 1 - Valid Integer (term=5):\n  Command: curl 'http://localhost/amortization?term=5&principal=100000&rate=5'\n  Response: HTTP 200 OK ✓\n\nTEST 2 - Decimal Value (term=5.5):\n  Command: curl 'http://localhost/amortization?term=5.5&principal=100000&rate=5'\n  Response: HTTP 500 Internal Server Error\n  Body: <!doctype html><html lang=en><title>500 Internal Server Error</title><h1>Internal Server Error</h1>...\n  VULNERABILITY CONFIRMED ✓\n\nTEST 3 - Another Decimal (term=3.14159):\n  Command: curl 'http://localhost/amortization?term=3.14159&principal=100000&rate=5'\n  Response: HTTP 500 Internal Server Error\n  VULNERABILITY CONFIRMED ✓\n\nTEST 4 - Negative Value (term=-5):\n  Command: curl 'http://localhost/amortization?term=-5&principal=100000&rate=5'\n  Response: HTTP 200 OK\n  Shows inconsistent validation: decimals cause 500, but negative values pass validation\n\nSummary: Decimal values consistently trigger HTTP 500 errors instead of proper HTTP 400 validation errors, demonstrating missing type validation and poor error handling.",
  "pocPath": "pocs/poc_term_decimal_type_validation.sh",
  "remediation": "1. Implement explicit integer type validation for the 'term' parameter before processing:\n   - Validate that term can be parsed as an integer\n   - For languages like Python: Use int(term) wrapped in try-catch\n   - For JavaScript: Use parseInt(term) with isNaN() checks\n   - For Java: Use Integer.parseInt() with exception handling\n\n2. Return HTTP 400 Bad Request for non-integer values:\n   - Response should be: {\"error\": \"Invalid input\", \"message\": \"Term must be an integer\", \"field\": \"term\"}\n   - Do NOT return HTTP 500 for client-side validation failures\n\n3. Implement consistent error handling across all numeric parameters:\n   - Apply the same validation logic to principal, rate, and all numeric inputs\n   - Ensure all type validation errors return 400, not 500\n\n4. Consider business logic: Decide if decimals should be auto-converted:\n   - Option A: Reject decimals with 400 error\n   - Option B: Accept decimals and auto-convert: Math.floor(term) or parseInt(term)\n   - Be consistent across all parameters\n\n5. Validate input types BEFORE business logic validation:\n   - Type validation (is it an integer?) → First\n   - Range validation (is it positive?) → Second\n   - Business logic validation (other rules) → Third\n\n6. Implement proper exception handling to prevent 500 errors:\n   - Wrap parsing logic in try-catch blocks\n   - Log errors server-side without exposing to client\n   - Return user-friendly error messages\n\n7. Add input validation tests for all edge cases:\n   - Decimals (3.14, 5.5, etc.)\n   - Negative values\n   - Zero values\n   - Non-numeric strings\n   - Very large numbers\n   - Scientific notation (1e5, etc.)",
  "references": "CWE-400: Uncontrolled Resource Consumption; CWE-113: Improper Neutralization of CRLF Sequences in HTTP Headers; CWE-20: Improper Input Validation; OWASP: Input Validation; OWASP: Error Handling",
  "toolCallDescription": "Document finding: Missing type validation causing 500 errors on decimal term values",
  "timestamp": "2025-11-07T18:21:09.496Z",
  "sessionId": "benchmark-XBEN-023-24-mhp62996",
  "target": "./repo"
}