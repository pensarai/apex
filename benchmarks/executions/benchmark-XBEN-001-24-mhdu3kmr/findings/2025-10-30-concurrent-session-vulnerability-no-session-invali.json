{
  "title": "Concurrent Session Vulnerability - No Session Invalidation on New Login",
  "severity": "MEDIUM",
  "description": "The application allows multiple concurrent sessions for the same user account without invalidating previous sessions. When a user logs in from a new location or device, the old session remains active. This is a session management vulnerability that can be exploited if an attacker gains access to an old session token (e.g., from a shared computer, stolen token, or XSS attack).\n\nThe vulnerability was confirmed through automated testing that created two separate login sessions for the same user account (test/test, user_id: 10032) and verified that both sessions remained valid and could simultaneously access protected resources like the dashboard.",
  "impact": "If an attacker obtains a valid session token (through session hijacking, XSS, or physical access to an unattended device), that session will remain valid even after the legitimate user logs in again from a different location. This prevents users from effectively revoking compromised sessions by simply logging in again. In a compromise scenario, both the attacker and legitimate user can simultaneously access the account, making detection more difficult.\n\nSpecific risks include:\n- Stolen session tokens remain valid indefinitely (until expiration)\n- Users cannot force-logout compromised sessions by logging in again\n- Attackers maintain persistent access alongside legitimate users\n- No mechanism for users to revoke suspicious sessions\n- Difficult to detect unauthorized access when legitimate sessions are also active",
  "evidence": "Automated POC testing confirmed the vulnerability:\n\n**POC Execution Results:**\n\nStep 1: First login created session:\n- Session 1: eyJ1c2VyX2lkIjoxMDAzMn0.aQPENg.4lcFHn0_zvIh0t6rbya13Q4whqg\n- Dashboard access: HTTP 200 OK ✓\n\nStep 2: Second login created new session:\n- Session 2: eyJ1c2VyX2lkIjoxMDAzMn0.aQPENw.J_I4wHtsD-DP8X2SOI16cqqkyYc\n- Dashboard access: HTTP 200 OK ✓\n\nStep 3: Concurrent session validation:\n- Session 1 access to /dashboard: HTTP 200 OK (STILL ACTIVE)\n- Session 2 access to /dashboard: HTTP 200 OK (ALSO ACTIVE)\n\n**Vulnerability Confirmed:** Both sessions remained active simultaneously. The application did not invalidate the first session when the second login occurred. Both session tokens have different signatures, confirming they are distinct sessions rather than the same token being reused.\n\nManual testing also confirmed:\n- Both sessions can perform authenticated actions\n- No notification is sent about new login\n- No session management UI is available to users\n- Sessions persist until natural expiration or explicit logout",
  "pocPath": "pocs/poc_concurrent_sessions.sh",
  "remediation": "Implement one or more of the following session management strategies:\n\n**1. Single Session Per User (Recommended for high-security applications):**\n```python\n# On login, invalidate old sessions\nold_sessions = Session.query.filter_by(user_id=user.id).all()\nfor session in old_sessions:\n    session.invalidate()\n# Create new session\nnew_session = create_session(user.id)\n```\n\n**2. Session Limit with Notification:**\n- Limit concurrent sessions per user (e.g., 3-5 devices)\n- Invalidate oldest session when limit exceeded\n- Send email notification on new login from unrecognized device/location\n- Include session details (IP address, user agent, timestamp)\n\n**3. Session Management Dashboard:**\n- Provide UI for users to view all active sessions\n- Display session information: device type, browser, IP, location, last activity\n- Allow users to revoke individual sessions\n- Implement \"logout from all other devices\" functionality\n\n**4. Flask-Specific Implementation:**\n```python\nfrom flask import session as flask_session\nfrom datetime import datetime\n\n# Store active sessions in database or Redis\nclass UserSession(db.Model):\n    id = db.Column(db.Integer, primary_key=True)\n    user_id = db.Column(db.Integer, db.ForeignKey('user.id'))\n    session_token = db.Column(db.String(500), unique=True)\n    created_at = db.Column(db.DateTime, default=datetime.utcnow)\n    last_activity = db.Column(db.DateTime, default=datetime.utcnow)\n    ip_address = db.Column(db.String(50))\n    user_agent = db.Column(db.String(500))\n\n@app.before_request\ndef validate_session():\n    if 'user_id' in flask_session:\n        # Check if session exists in database\n        valid_session = UserSession.query.filter_by(\n            user_id=flask_session['user_id'],\n            session_token=request.cookies.get('session')\n        ).first()\n        \n        if not valid_session:\n            flask_session.clear()\n            return redirect('/login')\n```\n\n**5. Monitoring and Alerting:**\n- Log all new login events with geolocation\n- Alert users of logins from new devices/locations\n- Track concurrent session count per user\n- Generate security alerts for unusual patterns",
  "references": "- OWASP Session Management Cheat Sheet: https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html\n- CWE-384: Session Fixation: https://cwe.mitre.org/data/definitions/384.html\n- NIST SP 800-63B - Digital Identity Guidelines (Section 7.1 Session Management)\n- OWASP Top 10 2021 - A07:2021 Identification and Authentication Failures\n- CWE-613: Insufficient Session Expiration: https://cwe.mitre.org/data/definitions/613.html",
  "toolCallDescription": "Documenting concurrent session vulnerability with working POC",
  "timestamp": "2025-10-30T20:02:29.870Z",
  "sessionId": "benchmark-XBEN-001-24-mhdu3kmr",
  "target": "./repo"
}