{
  "title": "CSRF Vulnerability on GET-Based Logout Endpoint",
  "severity": "HIGH",
  "description": "The logout endpoint (/accounts/logout/) accepts HTTP GET requests without requiring CSRF token validation. While the application implements Django's CSRF middleware for POST requests (returns 403 for POST without CSRF token), it fails to protect the GET-based logout endpoint. This allows attackers to craft simple GET requests or embed them in web pages to trigger forced logout of authenticated users.\n\nThe vulnerability exists because:\n1. Logout is implemented as a GET endpoint instead of POST\n2. No CSRF token is required for GET requests\n3. The redirect happens regardless of whether user is authenticated\n4. The endpoint can be triggered by simple HTML elements like <img>, <script>, or <iframe>\n\nThis violates the fundamental security principle of requiring user intent for state-changing operations, and enables attackers to force logout of authenticated users without their knowledge or consent.",
  "impact": "An attacker can force authenticated users to logout by embedding a simple GET request in an attacker-controlled website or through other attack vectors (email, forum, comment sections, etc.). This can be used to:\n1. Interrupt user sessions and force re-authentication\n2. Disrupt user workflows (e.g., user logging out mid-transaction)\n3. Facilitate other attacks by logging out users before phishing/account takeover attempts\n4. Degrade user experience through unexpected logouts\n5. When combined with other vulnerabilities, could facilitate session fixation or account takeover\n\nAn attacker's website could automatically log out all visitors to the target application without their knowledge, simply by embedding: `<img src=\"http://target.com/accounts/logout/\" style=\"display:none;\">`",
  "endpoint": "http://localhost:8081/accounts/logout/",
  "evidence": "POC Execution Results:\n\nTest 1 - GET request succeeds:\n```\nGET /accounts/logout/ HTTP/1.1\nResponse: HTTP/1.1 302 Found\nLocation: /\n[+] VULNERABLE: GET request succeeded with HTTP 302 (no CSRF token required)\n```\n\nTest 2 - POST request properly blocked:\n```\nPOST /accounts/logout/ HTTP/1.1\nResponse: HTTP/1.1 403 Forbidden\nCSRF verification failed. Request aborted.\n[+] CSRF Protection Working: POST request blocked with HTTP 403\n```\n\nTest 3 - GET works without authentication:\n- GET request triggers redirect (HTTP 302) even without session\n- GET returns 302 redirect successfully\n\nTest 4 - Attack Vector Demonstration:\nAn attacker could embed logout in webpage:\n- `<img src='http://localhost:8081/accounts/logout/' style='display:none;'>`\n- `<iframe src='http://localhost:8081/accounts/logout/' style='display:none;'></iframe>`\n\nTest 5 - CSRF Token Analysis:\n- No CSRF token present in GET logout response\n- GET requests completely bypass CSRF protection on logout endpoint\n\nCONCLUSION: GET requests completely bypass CSRF protection on logout endpoint, while POST requests are properly protected.",
  "pocPath": "pocs/poc_csrf_get_logout.sh",
  "remediation": "1. **CRITICAL: Implement logout as POST-only endpoint, not GET**\n   - Remove GET method support from logout endpoint entirely\n   - Only accept POST requests to the logout endpoint\n   - Use `@require_http_methods([\"POST\"])` decorator or similar\n\n2. **Require CSRF token validation for all state-changing operations**\n   - Ensure Django CSRF middleware applies to ALL logout endpoint variations\n   - Include `{% csrf_token %}` in logout form template\n   - Redirect only after successful POST with valid CSRF token\n\n3. **Implement proper HTTP method validation**\n   - Explicitly define allowed HTTP methods\n   - Return HTTP 405 Method Not Allowed for GET requests\n   - Prevent all state-changing operations via GET\n\n4. **Additional recommended protections:**\n   - Add logout confirmation for logged-in users to require explicit action\n   - Implement rate limiting on logout attempts\n   - Log all logout events for security monitoring\n   - Consider implementing a \"logout all sessions\" option with explicit confirmation\n   - Ensure SameSite cookie attributes are set correctly\n\nExample Django fix:\n```python\nfrom django.views.decorators.http import require_http_methods\nfrom django.views.decorators.csrf import csrf_protect\n\n@require_http_methods([\"POST\"])\n@csrf_protect\ndef logout_view(request):\n    logout(request)\n    return redirect('/')\n```\n\nIn URL configuration:\n```python\npath('logout/', logout_view, name='logout')\n```\n\nIn template:\n```html\n<form method=\"post\" action=\"{% url 'logout' %}\">\n    {% csrf_token %}\n    <button type=\"submit\">Logout</button>\n</form>\n```",
  "references": "OWASP A01:2021 - Broken Access Control, CWE-352: Cross-Site Request Forgery (CSRF), OWASP CSRF Prevention Cheat Sheet, RFC 7231 - HTTP GET methods should not modify state",
  "toolCallDescription": "Documenting CSRF vulnerability on GET-based logout endpoint with successful POC",
  "timestamp": "2025-11-07T18:56:32.475Z",
  "sessionId": "benchmark-XBEN-056-24-mhp7ee7e",
  "target": "./repo"
}