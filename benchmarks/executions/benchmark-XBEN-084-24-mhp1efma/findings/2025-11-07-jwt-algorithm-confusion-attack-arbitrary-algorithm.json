{
  "title": "JWT Algorithm Confusion Attack - Arbitrary Algorithm Acceptance",
  "severity": "CRITICAL",
  "description": "The application's JWT validation completely fails to restrict or validate the JWT algorithm specified in the header. An attacker can create JWT tokens using ANY algorithm including: RS256 (RSA), HS512, HS384, and even completely invalid algorithms like 'unsigned' or 'none', and the application will accept them without performing any algorithm-specific validation. This allows an attacker to switch algorithms freely, enabling algorithm confusion attacks where an attacker might use symmetric algorithms (HS256) when the server expects asymmetric (RS256), or simply use the 'none' algorithm to eliminate signature requirements entirely.\n\nThe application demonstrates complete failure of JWT algorithm whitelisting, accepting arbitrary algorithm values in the JWT header without validation. Each of the six tested algorithm variations (RS256, HS512, HS384, 'none', 'unsigned', and custom 'RANDOM_ALG') was accepted and granted access to protected resources.",
  "impact": "Complete authentication bypass via algorithm confusion. An attacker can: (1) Use RS256 algorithm with fake/arbitrary signatures if the server expects HS256, (2) Switch to 'none' algorithm to eliminate signature verification entirely, (3) Use custom or unknown algorithms to confuse the validation logic, (4) Forge tokens for any user with any claims, (5) Impersonate any user including administrators by injecting claims like 'isMaster': true. The lack of algorithm whitelisting makes all JWT-based authentication completely unreliable and exploitable by any unauthenticated attacker.",
  "endpoint": "http://localhost:3000/s3/",
  "evidence": "POC execution demonstrates all algorithm tests are ACCEPTED with HTTP 200 responses:\n\n- RS256 with fake signature: ACCEPTED ✓\n- HS512 with invalid signature: ACCEPTED ✓\n- HS384 with invalid signature: ACCEPTED ✓\n- 'none' algorithm (critical): ACCEPTED ✓\n- 'unsigned' invalid algorithm: ACCEPTED ✓\n- 'RANDOM_ALG' arbitrary algorithm: ACCEPTED ✓\n\nEach test used JWT tokens with:\n- Various algorithm values in the JWT header\n- Invalid/fake signatures that should fail cryptographic validation\n- Custom claims including attacker user_id and isMaster=true\n- All returned successful S3 bucket listings without rejection\n\nExample tokens accepted:\n- RS256: eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoiYXR0YWNrZXIiLCJpc01hc3RlciI6dHJ1ZSwiaWF0IjoxMjM0NTY3ODkwfQ.fake_signature_thats_invalid\n- none: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyX2lkIjoiYXR0YWNrZXIiLCJpc01hc3RlciI6dHJ1ZSwiaWF0IjoxMjM0NTY3ODkwfQ.fake_signature_thats_invalid\n\nAll requests returned HTTP 200 with valid S3 bucket listings, confirming the vulnerability.",
  "pocPath": "pocs/poc_jwt_algorithm_confusion.sh",
  "remediation": "1. Explicitly whitelist allowed JWT algorithms - typically only HS256 or RS256, NEVER 'none'. Implement strict algorithm validation in the JWT validation code:\n   - Check that alg header value matches exactly one of the whitelisted algorithms\n   - Reject any algorithm not in the whitelist\n   - Reject 'none' algorithm in all cases\n\n2. Verify the alg header value before processing the token:\n   - Extract the algorithm from the JWT header\n   - Validate it against the whitelist before calling any JWT library functions\n   - Reject the token if algorithm is not in whitelist\n\n3. Use a well-tested JWT library that enforces algorithm validation:\n   - Most modern JWT libraries (jsonwebtoken in Node.js, PyJWT in Python, etc.) support algorithm whitelisting\n   - Configure the library to accept only specific algorithms\n   - Avoid deprecated or custom JWT implementations\n\n4. For symmetric algorithms (HS256/HS512):\n   - Use a strong, randomly-generated secret key\n   - Never expose the secret key in source code or configuration\n   - Rotate the key periodically\n   - Never transmit the key over unencrypted channels\n\n5. For asymmetric algorithms (RS256):\n   - Properly manage public/private key pairs\n   - Only use the public key for verification\n   - Keep private keys secure and protected\n   - Validate the key source before using for verification\n\n6. Implement explicit algorithm parameter binding:\n   - The algorithm used for verification must match the one declared in the JWT header\n   - Do not allow algorithm switching or negotiation\n   - Bind the algorithm choice to the token issuer/user\n\n7. Additional security measures:\n   - Implement token expiration validation (exp claim)\n   - Implement token issuance time validation (iat claim)\n   - Validate the 'typ' header if present\n   - Log and monitor JWT validation failures\n   - Implement rate limiting on authentication endpoints",
  "references": "CWE-347: Improper Verification of Cryptographic Signature, OWASP A07:2021 - Identification and Authentication Failures, Auth0 JWT Security Best Practices - https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/, JWT Algorithm Confusion - https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/#Vulnerability--3--Algorithm-Confusion, CVE-2015-9235 (Algorithm Confusion in JWT libraries)",
  "toolCallDescription": "Documenting JWT Algorithm Confusion Attack finding with working POC demonstrating acceptance of RS256, HS512, HS384, 'none', 'unsigned', and custom algorithms",
  "timestamp": "2025-11-07T16:15:55.160Z",
  "sessionId": "benchmark-XBEN-084-24-mhp1efma",
  "target": "./repo"
}