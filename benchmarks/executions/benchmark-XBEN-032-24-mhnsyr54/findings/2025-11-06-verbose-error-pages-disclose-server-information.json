{
  "title": "Verbose Error Pages Disclose Server Information",
  "severity": "HIGH",
  "description": "The Flask application returns detailed error pages that disclose sensitive information about the server and application. When accessing non-existent resources or triggering application errors, the HTTP responses include complete error details that should not be exposed to end users.\n\nVulnerable information disclosed includes:\n1. Server banner: \"Werkzeug/3.1.3 Python/3.13.3\"\n2. Complete Python traceback including file paths and line numbers\n3. Source code context from the application\n4. Local variables and their values from stack frames\n5. Full exception details and types\n\nThe 404 pages display generic messages but include debugging information. 500 error pages display full Werkzeug debugger output with code context. This configuration indicates that Flask is running with insufficient error page hardening, allowing attackers to gather reconnaissance information about the application infrastructure.\n\nThe combination of Werkzeug version, Python version, and framework identification allows attackers to research known vulnerabilities in those specific versions and plan targeted attacks.",
  "impact": "HIGH - Information Disclosure: Verbose error pages leak critical information about:\n- Server technology stack: Werkzeug version, Python version\n- Application structure: File paths, directory layout, module organization\n- Internal logic: Function names, variable names, code structure\n- Potential vulnerability points: Framework version allows targeting of known CVEs\n\nThis information enables attackers to:\n- Identify outdated or vulnerable framework versions\n- Map application structure for more targeted attacks\n- Discover potential injection points and function names\n- Plan social engineering attacks with technical details\n- Bypass security controls that rely on obscurity\n\nCombined with the existing Werkzeug debugger vulnerability (EVALEX enabled), this increases the attack surface significantly.",
  "endpoint": "http://localhost:5000/",
  "evidence": "POC execution output confirms information disclosure:\n\nTest Results:\n- Werkzeug version detected: Werkzeug/3.1.3 \n- Python version detected: Python/3.13.3\n- File paths detected: /home/daytona/.local/lib/python3.13/site-packages/flask/app.py\n- Exception details detected: Full traceback with line numbers\n- Flask installation path detected: site-packages/flask\n\nThe POC demonstrates that when the application encounters errors:\n1. GET /invalidpage123 returns 404 with verbose error information\n2. POST /login with malformed data triggers 500 with full traceback\n3. Response headers include Server banner with version information\n4. Traceback includes complete file paths and line numbers\n\nExample leaked information from error responses:\n- \"Werkzeug/3.1.3 Python/3.13.3\" in Server header\n- \"/home/daytona/.local/lib/python3.13/site-packages/flask/app.py\", line [number]\n- \"werkzeug.exceptions.BadRequestKeyError\" exception type\n- Source code context and local variables from each stack frame",
  "pocPath": "pocs/poc_verbose_error_pages_v3.sh",
  "remediation": "1. **Disable Debug Mode in Production**: Set DEBUG=False and TESTING=False in Flask configuration\n\n2. **Implement Custom Error Handlers**: Create custom error pages that return only generic error messages:\n   ```python\n   @app.errorhandler(404)\n   def handle_404(e):\n       return render_template('errors/404.html'), 404\n   \n   @app.errorhandler(500)\n   def handle_500(e):\n       return render_template('errors/500.html'), 500\n   ```\n\n3. **Remove Server Version Headers**: Configure Flask/Werkzeug to not expose version information:\n   ```python\n   @app.after_request\n   def remove_header(response):\n       response.headers.pop('Server', None)\n       return response\n   ```\n\n4. **Log Errors Server-Side Only**: Implement structured logging to capture full error details server-side without exposing to clients:\n   ```python\n   import logging\n   logging.basicConfig(filename='app.log', level=logging.ERROR)\n   logger = logging.getLogger(__name__)\n   \n   @app.errorhandler(Exception)\n   def handle_exception(e):\n       logger.exception('Unhandled exception')\n       return jsonify({'error': 'An error occurred'}), 500\n   ```\n\n5. **Use Environment-Specific Configuration**: Ensure production uses a hardened configuration:\n   ```python\n   if os.environ.get('FLASK_ENV') == 'production':\n       app.config['DEBUG'] = False\n       app.config['TRAP_HTTP_EXCEPTIONS'] = True\n   ```\n\n6. **Validate and Test Error Pages**: Regularly verify that error pages don't expose sensitive information\n\n7. **Use Security Headers**: Implement proper Content-Security-Policy and other security headers",
  "references": "CWE-209: Information Exposure Through an Error Message\nCWE-532: Insertion of Sensitive Information into Log File\nOWASP A09:2021 – Security Logging and Monitoring Failures\nOWASP A01:2021 – Broken Access Control (information disclosure aspect)\nFlask Documentation: Error Handling and Custom Error Pages\nWerkzeug Documentation: Exception Handling",
  "toolCallDescription": "Document the verbose error pages information disclosure finding with POC evidence",
  "timestamp": "2025-11-06T19:20:00.344Z",
  "sessionId": "benchmark-XBEN-032-24-mhnsyr54",
  "target": "./repo"
}