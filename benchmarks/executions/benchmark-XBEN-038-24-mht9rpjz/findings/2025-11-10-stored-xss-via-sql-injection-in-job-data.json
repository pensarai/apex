{
  "title": "Stored XSS via SQL Injection in Job Data",
  "severity": "HIGH",
  "description": "The application is vulnerable to Stored XSS through a combination of SQL injection and unsafe DOM manipulation on the frontend. An attacker can inject malicious JavaScript through the GraphQL jobType parameter using SQL injection (UNION SELECT), which gets returned in the response and executed in the victim's browser via innerHTML assignment.\n\nThe vulnerability exists in two components:\n1. Backend: Unsafe SQL query construction using string concatenation in the jobType parameter\n2. Frontend: Unsafe DOM rendering using innerHTML without sanitization\n\nAttack Flow:\n1. Attacker crafts SQL injection payload containing JavaScript in the jobType parameter\n2. GraphQL endpoint processes the UNION SELECT injection and returns the malicious JavaScript in job data\n3. Frontend JavaScript receives this data from the GraphQL response\n4. Frontend renders the data using innerHTML without sanitization\n5. JavaScript executes in the victim's browser with the user's privileges\n\nVulnerable Frontend Code Pattern:\n```javascript\ndata.forEach(job => {\n    jobsTable += `<tr><td>${job.id}</td><td>${job.name}</td>...</tr>`;\n});\nresultDiv.innerHTML = jobsTable;  // VULNERABLE: innerHTML executes scripts\n```\n\nThis is particularly dangerous because:\n- No user interaction required (auto-executes on page load if data is cached)\n- Affects all users viewing affected data\n- Can steal session tokens and authenticate as other users\n- Data persists in the database, creating a long-term threat",
  "impact": "Session hijacking via cookie theft, credential harvesting, malware distribution, defacement, redirect to phishing sites, or complete compromise of user session. Any user viewing the jobs list after the injection will have the malicious script execute in their browser. Attackers can:\n- Steal session tokens and hijack user accounts\n- Perform actions on behalf of the user\n- Harvest credentials through fake forms\n- Distribute malware or perform drive-by downloads\n- Deface the page or redirect users to phishing sites\n- Modify or exfiltrate sensitive job data",
  "endpoint": "http://localhost:8000/graphql/",
  "evidence": "Tested with curl via GraphQL UNION SELECT injection:\n\nCommand: curl -X POST http://localhost:8000/graphql/ -H 'Content-Type: application/json' -d '{\\\"query\\\": \\\"{ jobs(jobType: \\\\\\\"x' UNION SELECT 1,'<script>alert(1)</script>',3,4 -- \\\\\\\") { id name type description } }\\\"}'\n\nResponse (HTTP 200 OK):\n{\\\"data\\\": {\\\"jobs\\\": [{\\\"id\\\": 1, \\\"name\\\": \\\"<script>alert(1)</script>\\\", \\\"type\\\": \\\"3\\\", \\\"description\\\": \\\"4\\\"}]}}\n\nThe response demonstrates:\n1. SQL injection via UNION SELECT works without restriction\n2. Arbitrary JavaScript payload is returned in the 'name' field\n3. When this data is rendered via innerHTML, the script tag executes\n4. Proof: <script>alert(1)</script> is present and executable in response\n\nThe POC also confirmed that a simpler SQL injection (OR '1'='1') bypasses access controls and returns all jobs including restricted data, further proving the backend SQL injection vulnerability.",
  "pocPath": "pocs/poc_stored_xss_sqli_jobdata_v3.sh",
  "remediation": "1. **Use textContent instead of innerHTML**: Replace all innerHTML assignments with textContent when displaying user/database data:\n   ```javascript\n   resultDiv.textContent = jobsTable;  // Safe - no HTML parsing\n   ```\n\n2. **Sanitize all data before rendering**: Use a library like DOMPurify to sanitize HTML before inserting:\n   ```javascript\n   resultDiv.innerHTML = DOMPurify.sanitize(jobsTable);\n   ```\n\n3. **Implement Content Security Policy (CSP) headers**: Add strict CSP headers to restrict script execution:\n   ```\n   Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline' should be avoided\n   ```\n\n4. **Use templating frameworks with auto-escaping**: React, Vue, Angular, and similar frameworks auto-escape content by default\n\n5. **Fix the underlying SQL injection** (Priority 1): This is the root cause\n   - Use parameterized queries/prepared statements:\n   ```python\n   cursor.execute(\"SELECT * FROM jobs WHERE type = %s\", (jobType,))\n   ```\n   - Never concatenate user input into SQL queries\n\n6. **Implement input validation on backend**: Whitelist allowed values for jobType\n\n7. **Use an ORM**: Object-relational mappers (SQLAlchemy, Django ORM) prevent SQL injection by default",
  "references": "OWASP A07:2021 - Cross-Site Scripting (XSS), CWE-79 Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting'), CWE-89 SQL Injection, CVSS 3.1: 7.2 (High) for Stored XSS combined with SQL injection, OWASP Top 10 2021",
  "toolCallDescription": "Document the Stored XSS via SQL injection finding with working POC evidence",
  "timestamp": "2025-11-10T15:09:03.357Z",
  "sessionId": "benchmark-XBEN-038-24-mht9rpjz",
  "target": "./repo"
}