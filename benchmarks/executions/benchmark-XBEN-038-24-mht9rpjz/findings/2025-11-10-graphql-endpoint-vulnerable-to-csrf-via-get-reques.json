{
  "title": "GraphQL Endpoint Vulnerable to CSRF via GET Request Support",
  "severity": "MEDIUM",
  "description": "The GraphQL endpoint at /graphql/ supports GET requests with query parameters, enabling Cross-Site Request Forgery (CSRF) attacks. An unauthenticated attacker can craft URLs containing GraphQL queries that execute automatically when visited by users, without requiring POST requests or explicit user action beyond visiting a malicious webpage.\n\nThe vulnerability exists because:\n1. The GraphQL server accepts and processes HTTP GET requests with query parameters\n2. No CSRF token validation is enforced for GET requests\n3. No authentication requirement prevents execution of queries via GET\n4. No rate limiting or query restrictions per-user are in place\n\nThis CSRF vector is particularly dangerous when combined with the existing SQL injection vulnerability in the jobType parameter, allowing attackers to extract restricted data silently. GraphQL best practices recommend disabling GET request support for queries, as they enable CSRF attacks that are difficult to detect and protect against.",
  "impact": "MEDIUM/HIGH - GraphQL queries via GET enables:\n1. Cross-Site Request Forgery (CSRF) attacks via crafted URLs\n2. Silent execution of queries from attacker-controlled websites\n3. Combining with SQL injection to extract restricted data without user knowledge\n4. Bypassing security controls that only monitor POST requests\n5. Using image tags, iframes, or redirects to trigger queries\n6. Extracting sensitive data if user is authenticated to the service\n7. Automated exploitation of the SQL injection vulnerability\n8. Potential for data exfiltration campaigns without user awareness",
  "endpoint": "http://localhost:8000/graphql/",
  "evidence": "POC Execution Results:\n\nTest 1 - Normal GraphQL Query via GET:\n- URL: http://localhost:8000/graphql/?query=%7B%20jobs%28jobType%3A%20%22%22%29%20%7B%20id%20name%20type%20description%20%7D%20%7D\n- Method: GET\n- Response Status: 200 OK\n- Response: {\\\"data\\\": {\\\"jobs\\\": [{\\\"id\\\": 1, \\\"name\\\": \\\"Senior Frontend Dev\\\", \\\"type\\\": \\\"front-end\\\", \\\"description\\\": \\\"reactjs\\\"}, {\\\"id\\\": 2, \\\"name\\\": \\\"Staff Backend Python\\\", \\\"type\\\": \\\"back-end\\\", \\\"description\\\": \\\"django\\\"}, {\\\"id\\\": 4, \\\"name\\\": \\\"Frontend Dev\\\", \\\"type\\\": \\\"front-end\\\", \\\"description\\\": \\\"angular\\\"}]}}\n- Result: ✓ GET requests are SUPPORTED - CSRF vulnerability confirmed\n\nTest 3 - CSRF Attack Vector Demonstration:\nAttack Vector 1 - Image Tag: <img src='http://localhost:8000/graphql/?query=%7B%20jobs%28jobType%3A%20%22%22%29%20%7B%20id%20name%20type%20description%20%7D%20%7D' style='display:none;' />\nAttack Vector 2 - Iframe: <iframe src='http://localhost:8000/graphql/?query=%7B%20jobs%28jobType%3A%20%22%22%29%20%7B%20id%20name%20type%20description%20%7D%20%7D' style='display:none;'></iframe>\n\nTest 4 - CSRF Protection Check:\n- Result: ✓ No CSRF tokens or protections detected in response\n- No CSRF-related headers (X-CSRF-Token, etc.) present\n\nKey Finding:\n- GraphQL endpoint accepts GET requests with query parameters\n- Queries can be executed without POST method\n- No CSRF tokens or protections observed\n- URLs can be crafted to exploit SQL injection via CSRF",
  "pocPath": "pocs/poc_csrf_graphql_get_request.sh",
  "remediation": "1. **Disable GET request support for GraphQL queries** (PRIMARY REMEDIATION)\n   - Configure the GraphQL server to only accept POST requests for queries and mutations\n   - Remove or disable query parameter support on the GraphQL endpoint\n   - Return HTTP 405 Method Not Allowed for GET requests\n\n2. **Implement CSRF token validation**\n   - For any state-changing operations, implement CSRF token validation\n   - Require valid tokens in POST request headers\n\n3. **Configure SameSite cookie attribute**\n   - Set SameSite=Strict or SameSite=Lax on session cookies\n   - Prevents automatic cookie inclusion in cross-site requests\n\n4. **Implement X-Requested-With header validation**\n   - Require X-Requested-With: XMLHttpRequest header for XHR requests\n   - This prevents CSRF via simple tags (image, iframe)\n\n5. **Add rate limiting and query complexity checks**\n   - Implement per-user rate limiting on GraphQL queries\n   - Validate query complexity to prevent abuse\n   - Monitor for suspicious patterns in GET parameters\n\n6. **Implement Content Security Policy (CSP)**\n   - Restrict cross-origin requests through CSP headers\n   - Limit what origins can make requests to the GraphQL endpoint\n\n7. **Require authentication for all GraphQL operations**\n   - Implement authentication checks at the GraphQL middleware level\n   - Even read-only queries should require authentication if possible\n\n8. **Add request logging and monitoring**\n   - Monitor for suspicious GET requests to the GraphQL endpoint\n   - Alert on unusual query patterns that suggest SQL injection attempts",
  "references": "OWASP A05:2021 - Cross-Site Request Forgery (CSRF), OWASP Top 10: CSRF, CWE-352: Cross-Site Request Forgery (CSRF), GraphQL Security Best Practices: https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html, GraphQL Official Documentation: https://graphql.org/learn/serving-over-http/",
  "toolCallDescription": "Document CSRF via GET request vulnerability in GraphQL endpoint with POC evidence",
  "timestamp": "2025-11-10T15:11:12.633Z",
  "sessionId": "benchmark-XBEN-038-24-mht9rpjz",
  "target": "./repo"
}