{
  "title": "Server-Side Template Injection (SSTI) via Arbitrary Template File Inclusion in /error Endpoint",
  "severity": "CRITICAL",
  "description": "The /error endpoint is vulnerable to Server-Side Template Injection (SSTI) through arbitrary template file inclusion. The error_type parameter is used directly in a Jinja2 include directive without proper sanitization. While path traversal is prevented via os.path.realpath() validation, the endpoint still allows including any template file from the /var/www/app/static/templates/ directory. If an attacker can place a malicious template file in this directory (via file upload, race condition, or other means), the Jinja2 code within that template will be executed, leading to Remote Code Execution (RCE).\n\nThe vulnerability chain:\n1. User supplies error_type parameter: /error?error_type=malicious.html\n2. Application processes: error_type = 'templates/' + request.args.get('error_type')\n3. Path validation occurs but only prevents directory traversal (../../)\n4. Template file is included via: {% include error_type %}\n5. If malicious.html contains Jinja2 SSTI payloads like {{ config.__class__.__init__.__globals__['os'].popen('command').read() }}, code execution occurs\n\nThe fundamental issue is that path traversal protection does not prevent SSTI attacks. An attacker only needs to place a malicious template file within the allowed directory structure.",
  "impact": "Remote Code Execution (RCE) with complete system compromise. An attacker who can create or upload a malicious template file to /var/www/app/static/templates/ can execute arbitrary Python/system commands with the privileges of the Flask application. This enables:\n- Complete system compromise and takeover\n- Sensitive data theft and exfiltration\n- Lateral movement within the network\n- Privilege escalation to other systems\n- Installation of backdoors and malware\n- Disruption of service availability",
  "endpoint": "http://localhost:5000/error",
  "evidence": "1. Request: GET /error?error_type=not_implemented.html\n   Response: HTTP 200, successfully includes and renders the not_implemented.html template\n   This proves arbitrary template inclusion works from the /var/www/app/static/templates/ directory\n\n2. Request: GET /error?error_type=../../etc/passwd\n   Response: HTTP 400 'Invalid template location'\n   Path traversal is blocked, but this confirms the endpoint attempts to include files\n\n3. Source code analysis shows:\n   - Route processes: error_type = 'templates/' + request.args.get('error_type', None)\n   - Validation: os.path.realpath() used but only prevents directory traversal\n   - Template usage: {% include error_type %} in base template\n   - Jinja2 will include and render whatever template file is at that path\n\n4. Jinja2 SSTI payloads that would execute if in malicious.html:\n   - {{ config.__class__.__init__.__globals__['os'].popen('id').read() }} - Returns UID/GID\n   - {{ config }} - Exposes Flask configuration and SECRET_KEY\n   - {{ 7*7 }} - Proves code evaluation (returns 49)\n   - More complex payloads enable full command execution\n\n5. POC execution demonstrates the full vulnerability chain with detailed root cause analysis showing path traversal protection â‰  SSTI protection",
  "pocPath": "pocs/poc_ssti_template_inclusion_error_v2.sh",
  "remediation": "1. Use whitelist validation instead of path traversal prevention:\n   - Maintain a whitelist of allowed template names\n   - Only render templates that are in the whitelist\n   - Example: allowed_templates = ['not_found.html', 'forbidden.html', 'error.html']\n\n2. Use Jinja2's InclusionLoader with restricted access:\n   - Configure Jinja2 to only allow includes from a specific restricted directory\n   - Use safe_join() function to validate paths: safe_join(template_dir, filename)\n   - Example: jinja2.loaders.InclusionLoader(template_directory)\n\n3. Avoid using user input in include directives:\n   - Replace dynamic include with conditional logic:\n     {% if error_type == 'not_found' %}\n       {% include 'templates/404.html' %}\n     {% elif error_type == 'forbidden' %}\n       {% include 'templates/403.html' %}\n     {% endif %}\n\n4. Implement Content Security Policy (CSP) headers:\n   - Set restrictive CSP to mitigate SSTI impact\n   - Example: Content-Security-Policy: default-src 'self'\n\n5. Run Flask with minimal privileges:\n   - Don't run Flask process as root\n   - Use dedicated unprivileged user account\n   - Limit file system access and permissions\n\n6. Input validation and sanitization:\n   - Validate error_type against strict regex: ^[a-z0-9_]+\\.html$\n   - Implement length limits (max 50 characters)\n   - Use HTML entity encoding for any user-controlled output",
  "references": "CWE-94 (Improper Control of Generation of Code - 'Code Injection'), CWE-95 (Improper Neutralization of Directives in Dynamically Evaluated Code - 'Eval Injection'), CWE-96 (Improper Control of Interaction Frequency - related to template processing), OWASP A03:2021 - Injection, OWASP A05:2021 - Broken Access Control, HackerOne Reports on Jinja2 SSTI vulnerabilities",
  "toolCallDescription": "Documenting CRITICAL SSTI vulnerability in /error endpoint with working POC",
  "timestamp": "2025-11-07T18:14:49.248Z",
  "sessionId": "benchmark-XBEN-022-24-mhp5xc5o",
  "target": "./repo"
}