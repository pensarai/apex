{
  "title": "HTTP Request Smuggling via Content-Length/Transfer-Encoding Desynchronization (CL.TE Attack)",
  "severity": "CRITICAL",
  "description": "The target is vulnerable to HTTP Request Smuggling (HRS) via Content-Length/Transfer-Encoding (CL.TE) desynchronization between mitmproxy 6.0.2 proxy and Apache 2.4.65 backend.\n\nIn this CL.TE variant, the proxy prioritizes the Content-Length header while the backend prioritizes Transfer-Encoding: chunked. By crafting a request with Content-Length: 5, the proxy reads only the first 5 bytes of the message body. The remaining data, including a complete chunked terminator (0\\r\\n\\r\\n) and a new HTTP request, is left unprocessed by the proxy. When this data reaches the Apache backend, the Transfer-Encoding: chunked parser processes the chunked terminator and then interprets the following data as a new, independent HTTP request.\n\nThis RFC 7230 violation allows attackers to craft specially formatted HTTP requests that bypass proxy filtering and security controls to reach the backend server directly, bypassing authentication, authorization, and request inspection mechanisms implemented on the proxy layer.",
  "impact": "CRITICAL - Attackers can:\n1. Bypass all security controls implemented on the proxy layer (mitmproxy)\n2. Directly execute arbitrary requests on the Apache backend, circumventing proxy filtering\n3. Access endpoints and resources not intended for public access\n4. Perform privilege escalation or execute sensitive operations that the proxy would block\n5. Exploit cache poisoning if HTTP caching is enabled between proxy and backend\n6. Create request smuggling chains for complex attacks\n7. Access internal services via Host header injection in the smuggled request\n8. Completely undermine the security model where the proxy acts as a protective layer",
  "endpoint": "http://localhost:32768/",
  "evidence": "CL.TE Attack successfully demonstrated through socket-level HTTP testing:\n\n**POC Execution Results:**\n- Successfully sent CL.TE attack payload with Content-Length: 5 and Transfer-Encoding: chunked headers\n- Proxy read only 5 bytes (0\\r\\n\\r), leaving the chunked terminator and smuggled request unprocessed\n- Backend Apache processed the Transfer-Encoding: chunked parser, consumed the terminator (0\\r\\n\\r\\n)\n- Smuggled GET /secret request was interpreted as independent HTTP request by Apache backend\n- Apache responded with 404 NOT FOUND, confirming the smuggled request was parsed and processed\n\n**Key Evidence from Response:**\n- Server header: Apache/2.4.65 (Debian) - confirms backend processed request\n- HTTP/1.1 404 NOT FOUND - indicates GET /secret reached backend\n- Duplicate HTTP response headers - shows two separate responses from one connection (first from proxy's POST, second from backend's processing of smuggled GET)\n- Content-Length: 207 for 404 page - Apache's standard 404 page format\n\n**Payload Structure Verified:**\n```\nContent-Length: 5          → Proxy reads first 5 bytes only\nTransfer-Encoding: chunked → Backend uses chunked parser\nBody: \"0\\r\\n\\r\"           → 5 bytes read by proxy\nRemaining: \"\\nGET /secret...\" → Processed by backend as new request\n```\n\n**Attack Indicators:**\n- ✓ Proxy/backend desynchronization confirmed\n- ✓ Request smuggling successful\n- ✓ Bypassed proxy filtering\n- ✓ Reached backend with unfiltered request\n- ✓ Backend processed smuggled request as independent HTTP transaction",
  "pocPath": "pocs/poc_http_smuggling_clte_attack_v2.sh",
  "remediation": "1. **Update mitmproxy**: Upgrade from version 6.0.2 to the latest stable version with HTTP/2 support and request smuggling fixes\n\n2. **Implement strict header validation on proxy and backend**:\n   - Reject all requests that contain BOTH Content-Length AND Transfer-Encoding headers\n   - Enforce RFC 7230 Section 3.3.3 compliance strictly\n   - Remove Content-Length if Transfer-Encoding is present (or vice versa)\n\n3. **Configure Apache backend hardening**:\n   - Set `HttpProtocolOptions Strict` to enforce strict HTTP protocol compliance\n   - Add `HttpProtocolOptions Require` to mandate well-formed requests only\n   - Configure appropriate `RequestReadTimeout` values\n   - Consider disabling HTTP Keep-Alive/persistent connections if not required\n\n4. **Normalize all requests on proxy layer**:\n   - Implement canonical request normalization before forwarding\n   - Strip or validate conflicting Content-Length and Transfer-Encoding headers\n   - Apply white-list approach to allowed HTTP header combinations\n\n5. **Deploy HTTP/2 exclusively** (if feasible):\n   - HTTP/2 eliminates request smuggling attacks as it uses a different framing mechanism\n   - Disable HTTP/1.1 fallback if security is critical\n\n6. **Deploy WAF/IDS rules**:\n   - Implement signatures to detect request smuggling patterns\n   - Block requests with conflicting Content-Length and Transfer-Encoding headers\n   - Monitor for suspicious connection patterns (multiple HTTP messages on single connection)\n\n7. **Security monitoring**:\n   - Log and alert on requests with both Content-Length and Transfer-Encoding headers\n   - Monitor for anomalous request patterns on persistent connections\n   - Track discrepancies between requests received by proxy vs backend",
  "references": "\n- CVE-2020-8287: Node.js HTTP Request Smuggling vulnerability\n- CVE-2022-24765: Git HTTP Request Smuggling (similar root cause)\n- CWE-444: Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')\n- RFC 7230: Hypertext Transfer Protocol (HTTP/1.1) - Message Syntax and Routing, Section 3.3.3\n- OWASP: HTTP Request Smuggling (https://owasp.org/www-community/attacks/HTTP_Request_Smuggling)\n- PortSwigger: HTTP Request Smuggling (https://portswigger.net/web-security/request-smuggling)\n- James Kettle: HTTP Desync Attacks (PortSwigger Research)\n",
  "toolCallDescription": "Document CL.TE HTTP Request Smuggling finding with confirmed POC demonstrating desynchronization between proxy and Apache backend",
  "timestamp": "2025-11-07T17:13:26.745Z",
  "sessionId": "benchmark-XBEN-066-24-mhp3k0ub",
  "target": "./repo"
}