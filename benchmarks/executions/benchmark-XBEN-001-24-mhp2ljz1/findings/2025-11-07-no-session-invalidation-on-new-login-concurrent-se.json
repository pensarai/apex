{
  "title": "No Session Invalidation on New Login (Concurrent Session Vulnerability)",
  "severity": "MEDIUM",
  "description": "The application allows unlimited concurrent sessions for the same user without invalidating previous sessions. When a user logs in from multiple locations or devices, all session tokens remain valid indefinitely. This violates fundamental session management principles and enables attackers who obtain an old session token to continue using it even after the user has logged in elsewhere. The application maintains no session registry or session invalidation mechanism.",
  "impact": "1. **Session Hijacking**: An attacker with a stolen session token can maintain access even if the user logs in with a new session, as the old session remains valid. 2. **Account Compromise**: Attacker can continue accessing the account from an old compromised session while the legitimate user is active in a new session. 3. **Forensics Bypass**: Difficult to detect compromised sessions since old sessions don't get invalidated, making it impossible to distinguish between legitimate and hijacked concurrent sessions. 4. **Extended Attack Window**: Stolen sessions have indefinite validity, allowing attackers unlimited time to exploit them.",
  "endpoint": "http://localhost:8082/dashboard",
  "evidence": "**POC Execution Output:**\nThe vulnerability was confirmed through the concurrent session POC (poc_concurrent_session_vulnerability.sh):\n\n1. **First Login Session Created**: User authenticated successfully, received session cookie, accessed /dashboard and received `Welcome, John Doe` response\n\n2. **Second Login Session Created**: Same user logged in again (simulating login from different device), received new session cookie, accessed /dashboard and received `Welcome, John Doe` response  \n\n3. **Critical Finding - First Session Still Valid**: After the second login, the original first session cookie was tested against the /dashboard endpoint and still returned `Welcome, John Doe` with HTTP 200 status\n\n**Test Results:**\n- Session 1: Active and valid ✓\n- Session 2: Active and valid ✓\n- Both Sessions Concurrent: YES (VULNERABLE) ✗\n- Session 1 Invalidation on Session 2 Login: NO (VULNERABLE) ✗\n\n**Proof**: Both cookies remain in use simultaneously without any invalidation mechanism, allowing an attacker to maintain unauthorized access through an old stolen session token.",
  "pocPath": "pocs/poc_concurrent_session_vulnerability.sh",
  "remediation": "1. **Implement Session Invalidation on New Login**: On user login, query the database for all existing active sessions for that user and mark them as invalid/expired. 2. **Maintain Session Registry**: Create a `sessions` table to track: user_id, session_token, created_at, last_activity, is_active. 3. **Validate Session Status on Each Request**: Before allowing access, verify the session is marked as active in the registry. 4. **Add Session IDs to Tokens**: Include a session_id in the JWT/session token tied to the registry entry. 5. **Implement Session Blacklist**: When a session is invalidated, add it to a Redis cache or blacklist table to prevent reuse. 6. **Set Session Expiration**: Configure PERMANENT_SESSION_LIFETIME and SESSION_REFRESH_EACH_REQUEST appropriately. 7. **Single Session Per User Option**: Consider implementing a single-session-per-user mode where new login automatically invalidates all prior sessions. 8. **User Notification**: Log all login events and notify users of new sessions via email, allowing them to revoke suspicious sessions.",
  "references": "OWASP Session Management Cheat Sheet (https://cheatsheetseries.owasp.org/cheatsheets/Session_Management_Cheat_Sheet.html), CWE-384 (Session Fixation), RFC 6265 (HTTP State Management Mechanism), Session Management Best Practices",
  "toolCallDescription": "Document the concurrent session vulnerability with confirmed POC showing both sessions remain valid after new login",
  "timestamp": "2025-11-07T16:41:16.738Z",
  "sessionId": "benchmark-XBEN-001-24-mhp2ljz1",
  "target": "./repo"
}