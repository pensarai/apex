import { useState } from "react";
import { useKeyboard } from "@opentui/react";
import type { ModelMessage } from "ai";
import { exec } from "child_process";
import Input from "../input";
import { useCommand } from "../../command-provider";
import { useAgent } from "../../agentProvider";
import { runAgent } from "../../../core/agent";
import AgentDisplay from "../agent-display";

interface ToolMessage {
  role: "tool";
  content: string;
}

type Message = ModelMessage | ToolMessage;

export default function PentestAgentDisplay() {
  const [focusedIndex, setFocusedIndex] = useState(0);
  const [target, setTarget] = useState("");
  const [objective, setObjective] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [hasStarted, setHasStarted] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionPath, setSessionPath] = useState<string>("");
  const { closePentest } = useCommand();
  const { model, addTokens, setThinking } = useAgent();

  const inputs = ["target", "objective"]; // List of input fields

  useKeyboard((key) => {
    // Escape - Close pentest display
    if (key.name === "escape") {
      closePentest();
      return;
    }

    // Enter - View report when completed
    if (isCompleted && key.name === "return") {
      openReport();
      return;
    }

    // Don't allow navigation if streaming has started
    if (hasStarted) {
      return;
    }

    // Tab - Next field
    if (key.name === "tab" && !key.shift) {
      setFocusedIndex((prev) => (prev + 1) % inputs.length);
      return;
    }

    // Shift+Tab - Previous field
    if (key.name === "tab" && key.shift) {
      setFocusedIndex((prev) => (prev - 1 + inputs.length) % inputs.length);
      return;
    }

    // Enter - Begin execution (when all fields filled)
    if (key.name === "return") {
      if (target && objective) {
        beginExecution();
      }
    }
  });

  function openReport() {
    if (sessionPath) {
      const reportPath = `${sessionPath}/pentest-report.md`;
      // Open the report in the default editor
      exec(`open "${reportPath}"`, (error) => {
        if (error) {
          console.error("Error opening report:", error);
        }
      });
    }
  }

  async function beginExecution() {
    if (target && objective && !hasStarted) {
      setHasStarted(true);
      setIsStreaming(true);
      setThinking(true);

      try {
        const result = runAgent({
          target,
          objective,
          model: model.id,
          onStepFinish: ({ usage }) => {
            // Track actual tokens from each step including tool calls
            const stepTokens =
              (usage.inputTokens ?? 0) + (usage.outputTokens ?? 0);
            addTokens(stepTokens);
          },
        });

        // Store session path for display
        setSessionPath(result.session.rootPath);

        // Add initial user message
        const userMessage: ModelMessage = {
          role: "user",
          content: `Target: ${target}\nObjective: ${objective}\n\nSession: ${result.session.id}\nPath: ${result.session.rootPath}`,
        };

        const allMessages: Message[] = [userMessage];
        let currentAssistantText = "";

        // Consume the full stream including text, tool calls, and tool results
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            // Accumulate text for the current assistant message
            currentAssistantText += delta.text;

            // Update or create the current assistant message
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              // Update existing assistant message
              lastMessage.content = currentAssistantText;
            } else {
              // Create new assistant message
              allMessages.push({
                role: "assistant",
                content: currentAssistantText,
              });
            }

            setMessages([...allMessages]);
          } else if (delta.type === "tool-call") {
            // Finalize current assistant text if any
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            setThinking(false);

            // Add tool call as a separate message with role: "tool"
            const toolName = delta.toolName;
            const input = JSON.stringify(delta.input, null, 2);
            allMessages.push({
              role: "tool",
              content: `ðŸ”§ Calling tool: ${toolName}`,
            });

            setMessages([...allMessages]);
          } else if (delta.type === "tool-result") {
            setThinking(true);

            // Add tool result as a separate message with role: "tool"
            const toolName = delta.toolName;
            const output =
              typeof delta.output === "string"
                ? delta.output
                : JSON.stringify(delta.output, null, 2);

            allMessages.push({
              role: "tool",
              content: `âœ“ Tool ${toolName}`,
            });

            setMessages([...allMessages]);
          }
        }

        setIsStreaming(false);
        setIsCompleted(true);
        setThinking(false);
      } catch (error) {
        console.error("Error during agent execution:", error);
        setIsStreaming(false);
        setThinking(false);

        const errorMessage: ModelMessage = {
          role: "assistant",
          content: `Error: ${
            error instanceof Error ? error.message : "Unknown error occurred"
          }`,
        };
        setMessages([errorMessage]);
      }
    }
  }

  // Otherwise, show the form
  return (
    <box
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      width="100%"
      maxHeight="100%"
      flexGrow={1}
      flexShrink={1}
      overflow="hidden"
      gap={1}
    >
      {hasStarted && (
        <AgentDisplay messages={messages} isStreaming={isStreaming}>
          {isCompleted && (
            <box
              border={true}
              borderColor="green"
              flexDirection="column"
              padding={1}
              gap={1}
              alignItems="center"
            >
              <text fg="green">âœ“ Pentest Completed</text>
              <text fg="white">Report generated successfully</text>
              <box flexDirection="row" gap={1}>
                <text fg="gray">Press</text>
                <text fg="green">[ENTER]</text>
                <text fg="gray">to view report</text>
                <text fg="gray">or</text>
                <text fg="green">[ESC]</text>
                <text fg="gray">to close</text>
              </box>
              <text fg="gray">{sessionPath}/pentest-report.md</text>
            </box>
          )}
        </AgentDisplay>
      )}

      {!hasStarted && (
        <box flexDirection="column" width="50%" gap={1}>
          <text fg="green">Pentest</text>
          <text fg="white">
            Run an automated penetration test and generate a comprehensive
            report for a given target.
          </text>
          <Input
            label="Target"
            description="The target to test"
            placeholder="Enter a target"
            value={target}
            onInput={setTarget}
            focused={focusedIndex === 0}
          />
          <Input
            label="Objective"
            description="The objective of the penetration test"
            placeholder="Enter an objective"
            value={objective}
            onInput={setObjective}
            focused={focusedIndex === 1}
          />
          <box flexDirection="row" width="100%" gap={1}>
            <text fg="gray">
              <span fg="green">[TAB]</span> Next Â· <span fg="green">[ESC]</span>{" "}
              Close Â·
            </text>
            <text fg="green">[ENTER]</text>
            <text fg="gray">Begin</text>
          </box>
        </box>
      )}
    </box>
  );
}
