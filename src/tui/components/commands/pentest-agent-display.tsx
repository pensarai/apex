import { useEffect, useState } from "react";
import { useKeyboard } from "@opentui/react";
import type { ModelMessage } from "ai";
import { exec } from "child_process";
import Input from "../input";
import { useCommand } from "../../command-provider";
import { useAgent } from "../../agentProvider";
import { runAgent } from "../../../core/agent/pentestAgent/agent";
import AgentDisplay from "../agent-display";
import fs from "fs";
import {
  saveMessages,
  type Message,
  type ToolMessage,
} from "../../../core/messages";

export default function PentestAgentDisplay() {
  const [focusedIndex, setFocusedIndex] = useState(0);
  const [target, setTarget] = useState("");
  const [objective, setObjective] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [hasStarted, setHasStarted] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionPath, setSessionPath] = useState<string>("");
  const [abortController, setAbortController] =
    useState<AbortController | null>(null);

  // Header configuration state
  const [headerMode, setHeaderMode] = useState<'none' | 'default' | 'custom'>('default');
  const [customHeaders, setCustomHeaders] = useState<Record<string, string>>({});
  const [headerInputName, setHeaderInputName] = useState('');
  const [headerInputValue, setHeaderInputValue] = useState('');
  const [selectedHeaderIndex, setSelectedHeaderIndex] = useState(0);
  const [headerEditMode, setHeaderEditMode] = useState<'list' | 'input'>('list');
  const [inputError, setInputError] = useState('');
  const [editingHeaderKey, setEditingHeaderKey] = useState<string | null>(null);

  const { closePentest } = useCommand();
  const {
    model,
    addTokens,
    setTokenCount,
    setThinking,
    isExecuting,
    setIsExecuting,
  } = useAgent();

  const inputs = headerMode === 'custom' && headerEditMode === 'input'
    ? ["target", "objective", "headerMode", "headerInputName", "headerInputValue"]
    : ["target", "objective", "headerMode"];

  const headerEntries = Object.entries(customHeaders);

  useKeyboard((key) => {
    // Escape - Close pentest display
    if (key.name === "escape") {
      closePentest();
      return;
    }

    // Ctrl+C - Abort execution if running
    if (key.ctrl && key.name === "c" && isExecuting && !isCompleted) {
      if (abortController) {
        abortController.abort();
      }
      return;
    }

    // Enter - View report when completed
    if (isCompleted && key.name === "return") {
      openReport();
      return;
    }

    // Don't allow navigation if streaming has started
    if (hasStarted) {
      return;
    }

    // Arrow Up/Down for radio buttons when focused on headerMode
    if (focusedIndex === 2 && key.name === 'up') {
      if (headerMode === 'custom' && headerEditMode === 'list') {
        // Navigate header list
        if (headerEntries.length > 0) {
          setSelectedHeaderIndex((prev) => (prev - 1 + headerEntries.length) % headerEntries.length);
        }
      } else {
        // Navigate mode selection
        const modes: Array<'none' | 'default' | 'custom'> = ['none', 'default', 'custom'];
        const currentIndex = modes.indexOf(headerMode);
        const newMode = modes[(currentIndex - 1 + 3) % 3];
        if (newMode) setHeaderMode(newMode);
      }
      return;
    }

    if (focusedIndex === 2 && key.name === 'down') {
      if (headerMode === 'custom' && headerEditMode === 'list') {
        // Navigate header list
        if (headerEntries.length > 0) {
          setSelectedHeaderIndex((prev) => (prev + 1) % headerEntries.length);
        }
      } else {
        // Navigate mode selection
        const modes: Array<'none' | 'default' | 'custom'> = ['none', 'default', 'custom'];
        const currentIndex = modes.indexOf(headerMode);
        const newMode = modes[(currentIndex + 1) % 3];
        if (newMode) setHeaderMode(newMode);
      }
      return;
    }

    // Hotkeys for custom mode
    if (headerMode === 'custom' && focusedIndex === 2) {
      // A = Add header
      if (key.name === 'a' && headerEditMode === 'list') {
        setHeaderEditMode('input');
        setHeaderInputName('');
        setHeaderInputValue('');
        setInputError('');
        setEditingHeaderKey(null);
        setFocusedIndex(3); // Focus on name input
        return;
      }

      // E = Edit selected header
      if (key.name === 'e' && headerEditMode === 'list' && headerEntries.length > 0) {
        const entry = headerEntries[selectedHeaderIndex];
        if (entry) {
          const [key, value] = entry;
          setHeaderInputName(key);
          setHeaderInputValue(value);
          setEditingHeaderKey(key);
          setHeaderEditMode('input');
          setInputError('');
          setFocusedIndex(3); // Focus on name input
        }
        return;
      }

      // D = Delete selected header
      if (key.name === 'd' && headerEditMode === 'list' && headerEntries.length > 0) {
        const entry = headerEntries[selectedHeaderIndex];
        if (entry) {
          const [keyToDelete] = entry;
          const newHeaders = { ...customHeaders };
          delete newHeaders[keyToDelete];
          setCustomHeaders(newHeaders);
          setSelectedHeaderIndex(Math.max(0, selectedHeaderIndex - 1));
        }
        return;
      }

      // ESC in input mode = go back to list
      if (key.name === 'escape' && headerEditMode === 'input') {
        setHeaderEditMode('list');
        setHeaderInputName('');
        setHeaderInputValue('');
        setInputError('');
        setEditingHeaderKey(null);
        setFocusedIndex(2); // Back to header mode selection
        return;
      }
    }

    // Enter to submit header (when in value field)
    if (headerMode === 'custom' && focusedIndex === 4 && key.name === 'return') {
      const headerName = headerInputName.trim();
      const headerValue = headerInputValue.trim();

      if (!headerName) {
        setInputError('Header name cannot be empty');
        return;
      }

      if (!/^[A-Za-z][A-Za-z0-9-]*$/.test(headerName)) {
        setInputError('Invalid header name - Use only letters, numbers, and hyphens');
        return;
      }

      // If editing, remove old key
      if (editingHeaderKey && editingHeaderKey !== headerName) {
        const newHeaders = { ...customHeaders };
        delete newHeaders[editingHeaderKey];
        newHeaders[headerName] = headerValue;
        setCustomHeaders(newHeaders);
      } else {
        setCustomHeaders({ ...customHeaders, [headerName]: headerValue });
      }

      // Go back to list mode
      setHeaderEditMode('list');
      setHeaderInputName('');
      setHeaderInputValue('');
      setInputError('');
      setEditingHeaderKey(null);
      setFocusedIndex(2); // Back to header mode selection
      return;
    }

    // Tab - Next field
    if (key.name === "tab" && !key.shift) {
      setFocusedIndex((prev) => (prev + 1) % inputs.length);
      return;
    }

    // Shift+Tab - Previous field
    if (key.name === "tab" && key.shift) {
      setFocusedIndex((prev) => (prev - 1 + inputs.length) % inputs.length);
      return;
    }

    // Enter - Begin execution (when all fields filled and not in header editing mode)
    if (key.name === "return" && focusedIndex < 3) {
      if (target && objective) {
        const sessionConfig = {
          offensiveHeaders: {
            mode: headerMode,
            headers: headerMode === 'custom' ? customHeaders : undefined,
          },
        };
        beginExecution(sessionConfig);
      }
    }
  });

  function openReport() {
    if (sessionPath) {
      const reportPath = `${sessionPath}/pentest-report.md`;
      // Open the report in the default editor
      exec(`open "${reportPath}"`, (error) => {
        if (error) {
          console.error("Error opening report:", error);
        }
      });
    }
  }

  async function beginExecution(sessionConfig?: any) {
    if (target && objective && !hasStarted) {
      setHasStarted(true);
      setThinking(true);
      setIsExecuting(true);

      // Create new abort controller for this execution
      const controller = new AbortController();
      setAbortController(controller);

      try {
        const { streamResult: result } = runAgent({
          target,
          objective,
          model: model.id,
          abortSignal: controller.signal,
          sessionConfig,
          onStepFinish: ({ usage }) => {
            // Track actual tokens from each step including tool calls
            const stepTokens =
              (usage.inputTokens ?? 0) + (usage.outputTokens ?? 0);
            setTokenCount(stepTokens);
          },
        });

        // Store session path for display
        setSessionPath(result.session.rootPath);

        // Add initial user message
        const userMessage: Message = {
          role: "user",
          content: `Target: ${target}\nObjective: ${objective}\n\nSession: ${result.session.id}\nPath: ${result.session.rootPath}`,
          createdAt: new Date(),
        };

        const allMessages: Message[] = [userMessage];
        let currentAssistantText = "";

        // Consume the full stream including text, tool calls, and tool results
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            // Accumulate text for the current assistant message
            currentAssistantText += delta.text;
            addTokens(1);

            // Update or create the current assistant message
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              // Update existing assistant message
              lastMessage.content = currentAssistantText;
            } else {
              // Create new assistant message
              allMessages.push({
                role: "assistant",
                content: currentAssistantText,
                createdAt: new Date(),
              });
            }

            setMessages([...allMessages]);
          } else if (delta.type === "tool-call") {
            // Finalize current assistant text if any
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            setThinking(false);

            // Add tool call as a pending message with toolCallId
            const toolName = delta.toolName;
            allMessages.push({
              role: "tool",
              status: "pending",
              toolCallId: delta.toolCallId,
              content: delta.input.toolCallDescription
                ? `${delta.input.toolCallDescription}`
                : `Calling tool: ${toolName}`,
              args: delta.input,
              toolName,
              createdAt: new Date(),
            });

            setMessages([...allMessages]);
          } else if (delta.type === "tool-result") {
            setThinking(true);

            // Find and update the existing tool message by toolCallId
            const toolName = delta.toolName;
            const existingToolMessageIndex = allMessages.findIndex(
              (msg) =>
                msg.role === "tool" &&
                (msg as ToolMessage).toolCallId === delta.toolCallId
            );

            if (existingToolMessageIndex !== -1) {
              // Update the existing message to completed status
              const existingMessage = allMessages[
                existingToolMessageIndex
              ] as ToolMessage;
              existingMessage.status = "completed";
              existingMessage.content = delta.input.toolCallDescription
                ? `✓ ${delta.input.toolCallDescription}`
                : `✓ Tool ${toolName}`;
              existingMessage.toolName = toolName;
              existingMessage.args = delta.input;
            }

            setMessages([...allMessages]);
          }
          saveMessages(result.session, allMessages);
        }

        if (fs.existsSync(result.session.rootPath + "/pentest-report.md")) {
          setIsCompleted(true);
        }

        setThinking(false);
        setIsExecuting(false);
      } catch (error) {
        console.error("Error during agent execution:", error);
        setThinking(false);
        setIsExecuting(false);

        // Check if this was an abort
        if (error instanceof Error && error.name === "AbortError") {
          const abortMessage: Message = {
            role: "assistant",
            content: "⚠️ Execution aborted by user",
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, abortMessage]);
        } else {
          const errorMessage: Message = {
            role: "assistant",
            content: `Error: ${
              error instanceof Error ? error.message : "Unknown error occurred"
            }`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, errorMessage]);
        }
      }
    }
  }

  // Otherwise, show the form
  return (
    <box
      alignItems="center"
      justifyContent="center"
      flexDirection="column"
      width="100%"
      maxHeight="100%"
      flexGrow={1}
      flexShrink={1}
      overflow="hidden"
      gap={1}
    >
      {hasStarted && (
        <AgentDisplay messages={messages} isStreaming={isExecuting}>
          {isCompleted && (
            <box
              border={true}
              borderColor="green"
              flexDirection="column"
              padding={1}
              gap={1}
              alignItems="center"
            >
              <text fg="green">✓ Pentest Completed</text>
              <text fg="white">Report generated successfully</text>
              <box flexDirection="row" gap={1}>
                <text fg="gray">Press</text>
                <text fg="green">[ENTER]</text>
                <text fg="gray">to view report</text>
                <text fg="gray">or</text>
                <text fg="green">[ESC]</text>
                <text fg="gray">to close</text>
              </box>
              <text fg="gray">{sessionPath}/pentest-report.md</text>
            </box>
          )}
        </AgentDisplay>
      )}

      {!hasStarted && (
        <box flexDirection="column" width="50%" gap={1}>
          <text fg="green">Pentest</text>
          <text fg="white">
            Run an automated penetration test and generate a comprehensive
            report for a given target.
          </text>
          <Input
            label="Target"
            onPaste={(text: string) => {
              const cleaned = String(text);
              setTarget((prev) => `${prev}${cleaned}`);
            }}
            description="The target to test"
            placeholder="Enter a target"
            value={target}
            onInput={setTarget}
            focused={focusedIndex === 0}
          />
          <Input
            label="Objective"
            description="The objective of the penetration test"
            placeholder="Enter an objective"
            value={objective}
            onInput={setObjective}
            focused={focusedIndex === 1}
          />

          {/* Offensive Headers Configuration */}
          <box
            border={true}
            width="100%"
            borderStyle="heavy"
            backgroundColor="black"
            borderColor={focusedIndex === 2 ? "green" : "gray"}
            flexDirection="column"
            padding={1}
          >
            <text fg="green">Offensive Request Headers</text>
            <text fg="gray">Configure headers for HTTP tools (curl, nmap, nikto, etc.)</text>
            <text fg="gray">─────────────────────────────────────────────────</text>

            {/* Radio buttons */}
            <box flexDirection="column">
              <text fg={headerMode === 'none' ? 'green' : 'gray'}>
                {headerMode === 'none' ? '●' : '○'} None <span fg="gray">(no custom headers)</span>
              </text>
              <text fg={headerMode === 'default' ? 'green' : 'gray'}>
                {headerMode === 'default' ? '●' : '○'} Default <span fg="gray">(User-Agent: pensar-apex)</span>
              </text>
              <text fg={headerMode === 'custom' ? 'green' : 'gray'}>
                {headerMode === 'custom' ? '●' : '○'} Custom <span fg="gray">(define headers below)</span>
              </text>
            </box>

            {/* Custom headers section */}
            {headerMode === 'custom' && (
              <box flexDirection="column">
                <text fg="gray">─────────────────────────────────────────────────</text>

                {/* Section A: Existing Headers List (only in list mode) */}
                {headerEditMode === 'list' && (
                  <box flexDirection="column">
                    {headerEntries.length > 0 ? (
                      <>
                        <text fg="green">Configured Headers:</text>
                        {headerEntries.map(([key, value], index) => (
                          <text
                            key={key}
                            fg={index === selectedHeaderIndex ? 'green' : 'gray'}
                          >
                            {index === selectedHeaderIndex ? '▸' : ' '} • {key}: {value}
                          </text>
                        ))}
                      </>
                    ) : (
                      <text fg="gray">No headers configured. Press [A] to add.</text>
                    )}
                  </box>
                )}

                {/* Section B: Add/Edit Header Input */}
                {headerEditMode === 'input' && (
                  <box flexDirection="column">
                    <text fg="green">{editingHeaderKey ? 'Edit Header' : 'Add Header'}</text>

                    <box flexDirection="row">
                      <text fg="gray">Name:  </text>
                      <input
                        value={headerInputName}
                        onInput={setHeaderInputName}
                        placeholder="User-Agent"
                        focused={focusedIndex === 3}
                        width={40}
                        backgroundColor="black"
                      />
                    </box>

                    <box flexDirection="row">
                      <text fg="gray">Value: </text>
                      <input
                        value={headerInputValue}
                        onInput={setHeaderInputValue}
                        placeholder="pensar-apex_client123"
                        focused={focusedIndex === 4}
                        width={40}
                        backgroundColor="black"
                      />
                    </box>

                    {inputError && <text fg="red">{inputError}</text>}
                  </box>
                )}

                {/* Preview Section - Always visible when headers exist */}
                {headerEntries.length > 0 && (
                  <box flexDirection="column">
                    <text fg="gray">─────────────────────────────────────────────────</text>
                    <text fg="green">Preview:</text>
                    {headerEntries.map(([key, value]) => (
                      <text key={key} fg="gray">
                        {key}: {value}
                      </text>
                    ))}
                  </box>
                )}

                {/* Hotkeys */}
                <text fg="gray">─────────────────────────────────────────────────</text>
                {headerEditMode === 'list' && (
                  <text fg="gray">
                    <span fg="green">[A]</span> Add  <span fg="green">[E]</span> Edit  <span fg="green">[D]</span> Delete  <span fg="green">[↑↓]</span> Navigate
                  </text>
                )}

                {headerEditMode === 'input' && (
                  <text fg="gray">
                    <span fg="green">[TAB]</span> Next Field  <span fg="green">[ENTER]</span> Save  <span fg="green">[ESC]</span> Cancel
                  </text>
                )}
              </box>
            )}

            {headerMode !== 'custom' && (
              <box flexDirection="column">
                <text fg="gray">─────────────────────────────────────────────────</text>
                <text fg="gray">
                  <span fg="green">[↑↓]</span> Select mode
                </text>
              </box>
            )}
          </box>

          <box flexDirection="row" width="100%" gap={1}>
            <text fg="gray">
              <span fg="green">[TAB]</span> Next · <span fg="green">[ESC]</span>{" "}
              Close ·
            </text>
            <text fg="green">[ENTER]</text>
            <text fg="gray">Begin</text>
          </box>
        </box>
      )}
    </box>
  );
}
