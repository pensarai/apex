import { useState } from "react";
import { useAgent } from "../../agentProvider";
import {
  saveMessages,
  type Message,
  type ToolMessage,
} from "../../../core/messages";
import type { ModelMessage } from "ai";
import fs from "fs";
import { runAgent } from "../../../core/agent/thoroughPentestAgent/agent";
import { exec } from "child_process";

const LOG_FILE = "/tmp/apex-debug.log";
function logToFile(message: string, data?: any) {
  const timestamp = new Date().toISOString();
  const logLine = `[${timestamp}] ${message} ${
    data ? JSON.stringify(data, null, 2) : ""
  }\n`;
  fs.appendFileSync(LOG_FILE, logLine);
}

export type Subagent = {
  id: string;
  name: string;
  type: "attack-surface" | "pentest";
  target: string;
  messages: Message[];
  createdAt: Date;
  status: "pending" | "completed" | "failed";
};

export default function useThoroughPentestAgent() {
  const [target, setTarget] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [hasStarted, setHasStarted] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionPath, setSessionPath] = useState<string>("");
  const [subagents, setSubagents] = useState<Subagent[]>([]);
  const [abortController, setAbortController] =
    useState<AbortController | null>(null);

  const {
    model,
    addTokens,
    setTokenCount,
    setThinking,
    isExecuting,
    setIsExecuting,
  } = useAgent();

  function openReport() {
    if (sessionPath) {
      const reportPath = `${sessionPath}/comprehensive-pentest-report.md`;
      // Try comprehensive report first, fall back to session directory
      if (fs.existsSync(reportPath)) {
        exec(`open "${reportPath}"`, (error) => {
          if (error) {
            console.error("Error opening report:", error);
          }
        });
      } else {
        // Open the session directory if report doesn't exist yet
        exec(`open "${sessionPath}"`, (error) => {
          if (error) {
            console.error("Error opening session:", error);
          }
        });
      }
    }
  }

  async function beginExecution() {
    if (target && !hasStarted) {
      setHasStarted(true);
      setThinking(true);
      setIsExecuting(true);

      // Create new abort controller for this execution
      const controller = new AbortController();
      setAbortController(controller);

      try {
        const { streamResult: result, session } = await runAgent({
          target,
          model: model.id,
          abortSignal: controller.signal,
          onStepFinish: ({ usage }) => {
            // Track actual tokens from each step including tool calls
            const stepTokens =
              (usage.inputTokens ?? 0) + (usage.outputTokens ?? 0);
            setTokenCount(stepTokens);
          },
          // Subagent callbacks for real-time tracking
          onSubagentSpawn: (subagentInfo) => {
            setSubagents((prev) => [
              ...prev,
              {
                id: subagentInfo.id,
                name: subagentInfo.name,
                type: subagentInfo.type,
                target: subagentInfo.target,
                messages: [],
                status: "pending",
                createdAt: new Date(Date.now() + 100),
              },
            ]);
          },
          onSubagentMessage: (subagentId, message) => {
            // LOG: Message received
            logToFile(`[Hook] Received message for ${subagentId}:`, {
              role: message.role,
              content:
                typeof message.content === "string"
                  ? message.content.substring(0, 50)
                  : message.content,
              contentLength:
                typeof message.content === "string"
                  ? message.content.length
                  : "not-string",
              hasContent: !!message.content,
              toolCallId:
                message.role === "tool"
                  ? (message as ToolMessage).toolCallId
                  : "n/a",
            });

            setSubagents((prev) => {
              const subIndex = prev.findIndex((s) => s.id === subagentId);
              if (subIndex === -1) {
                logToFile(`[Hook] Subagent ${subagentId} not found!`);
                return prev;
              }

              const sub = prev[subIndex];
              if (!sub) {
                return prev;
              }
              const messages = [...sub.messages];

              // Generate a unique message ID for deduplication
              const getMessageId = (msg: Message): string => {
                if (msg.role === "tool" && "toolCallId" in msg) {
                  return `tool-${(msg as ToolMessage).toolCallId}`;
                } else if (msg.role === "assistant") {
                  // For assistant messages, use timestamp + content length
                  const content =
                    typeof msg.content === "string"
                      ? msg.content
                      : JSON.stringify(msg.content);
                  return `assistant-${msg.createdAt.getTime()}-${
                    content.length
                  }`;
                } else {
                  return `${msg.role}-${msg.createdAt.getTime()}`;
                }
              };

              const messageId = getMessageId(message);

              // For tool messages, find by toolCallId and update
              if (message.role === "tool") {
                const toolMsg = message as ToolMessage;
                const existingIndex = messages.findIndex(
                  (m) =>
                    m.role === "tool" &&
                    (m as ToolMessage).toolCallId === toolMsg.toolCallId
                );

                if (existingIndex !== -1) {
                  // Update existing tool message
                  messages[existingIndex] = message;
                } else {
                  // Add new tool message - insert in correct position by timestamp
                  const insertIndex = messages.findIndex(
                    (m) => m.createdAt.getTime() > message.createdAt.getTime()
                  );
                  if (insertIndex === -1) {
                    messages.push(message);
                  } else {
                    messages.splice(insertIndex, 0, message);
                  }
                }
              }
              // For assistant messages during streaming, update the last assistant message
              else if (message.role === "assistant") {
                const lastMessage = messages[messages.length - 1];

                if (lastMessage && lastMessage.role === "assistant") {
                  // Only update if timestamps match (same logical message)
                  if (
                    lastMessage.createdAt.getTime() ===
                    message.createdAt.getTime()
                  ) {
                    messages[messages.length - 1] = message;
                  } else {
                    // Different message, append it
                    messages.push(message);
                  }
                } else {
                  // Add new assistant message
                  messages.push(message);
                }
              }
              // For user messages, check for duplicates before appending
              else {
                const existingIndex = messages.findIndex(
                  (m) => getMessageId(m) === messageId
                );
                if (existingIndex === -1) {
                  messages.push(message);
                }
              }

              // Create a new subagent object with updated messages
              const updatedSub: Subagent = { ...sub, messages };

              // LOG: Final state
              logToFile(
                `[Hook] Updated ${subagentId}, now has ${messages.length} messages`
              );
              if (message.role === "tool") {
                const toolInArray = messages.find(
                  (m) =>
                    m.role === "tool" &&
                    (m as ToolMessage).toolCallId ===
                      (message as ToolMessage).toolCallId
                );
                logToFile(`[Hook] Tool message in array:`, {
                  found: !!toolInArray,
                  content: toolInArray?.content,
                  contentLength:
                    typeof toolInArray?.content === "string"
                      ? toolInArray.content.length
                      : "not-string",
                });
              }

              // Return new array with updated subagent
              const newSubagents = [...prev];
              newSubagents[subIndex] = updatedSub;
              return newSubagents;
            });
          },
          onSubagentComplete: (subagentId, success) => {
            setSubagents((prev) =>
              prev.map((sub) =>
                sub.id === subagentId
                  ? { ...sub, status: success ? "completed" : "failed" }
                  : sub
              )
            );
          },
        });

        // Store session path for display
        setSessionPath(result.session.rootPath);

        // Add initial user message
        const userMessage: Message = {
          role: "user",
          content: `Target: ${target}\n\nSession: ${result.session.id}\nPath: ${result.session.rootPath}\n\nMode: Pentest (Orchestrator)`,
          createdAt: new Date(),
        };

        const allMessages: Message[] = [userMessage];
        let currentAssistantText = "";

        // Consume the full stream including text, tool calls, and tool results
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            // Accumulate text for the current assistant message
            currentAssistantText += delta.text;
            addTokens(1);

            // Update or create the current assistant message
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              // Update existing assistant message
              lastMessage.content = currentAssistantText;
            } else {
              // Create new assistant message
              allMessages.push({
                role: "assistant",
                content: currentAssistantText,
                createdAt: new Date(),
              });
            }

            setMessages([...allMessages]);
          } else if (delta.type === "tool-call") {
            // Finalize current assistant text if any
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            setThinking(false);

            // Add tool call as a pending message with toolCallId
            const toolName = delta.toolName;
            allMessages.push({
              role: "tool",
              status: "pending",
              toolCallId: delta.toolCallId,
              content: delta.input.toolCallDescription
                ? `${delta.input.toolCallDescription}`
                : `Calling tool: ${toolName}`,
              args: delta.input,
              toolName,
              createdAt: new Date(),
            });

            setMessages([...allMessages]);
          } else if (delta.type === "tool-result") {
            setThinking(true);

            // Find and update the existing tool message by toolCallId
            const toolName = delta.toolName;
            const existingToolMessageIndex = allMessages.findIndex(
              (msg) =>
                msg.role === "tool" &&
                (msg as ToolMessage).toolCallId === delta.toolCallId
            );

            if (existingToolMessageIndex !== -1) {
              // Update the existing message to completed status
              const existingMessage = allMessages[
                existingToolMessageIndex
              ] as ToolMessage;

              const newContent = delta.input.toolCallDescription
                ? `✓ ${delta.input.toolCallDescription}`
                : `✓ Tool ${toolName}`;

              existingMessage.status = "completed";
              existingMessage.content = newContent;
              existingMessage.toolName = toolName;
              existingMessage.args = delta.input;
            }

            setMessages([...allMessages]);
          }
          saveMessages(result.session, allMessages);
        }

        // Check for comprehensive report completion
        if (
          fs.existsSync(
            result.session.rootPath + "/comprehensive-pentest-report.md"
          )
        ) {
          setIsCompleted(true);
        }

        setThinking(false);
        setIsExecuting(false);
      } catch (error) {
        console.error("Error during agent execution:", error);
        setThinking(false);
        setIsExecuting(false);

        // Check if this was an abort
        if (error instanceof Error && error.name === "AbortError") {
          const abortMessage: Message = {
            role: "assistant",
            content: "⚠️ Execution aborted by user",
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, abortMessage]);
        } else {
          const errorMessage: Message = {
            role: "assistant",
            content: `Error: ${
              error instanceof Error ? error.message : "Unknown error occurred"
            }`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, errorMessage]);
        }
      }
    }
  }

  return {
    target,
    setTarget,
    messages,
    setMessages,
    hasStarted,
    setHasStarted,
    isCompleted,
    setIsCompleted,
    sessionPath,
    subagents,
    setSubagents,
    abortController,
    isExecuting,
    beginExecution,
    openReport,
  };
}
