import { useState } from "react";
import { useAgent } from "../../agentProvider";
import {
  saveMessages,
  type Message,
  type ToolMessage,
} from "../../../core/messages";
import type { ModelMessage } from "ai";
import fs from "fs";
import { runAgent } from "../../../core/agent/pentestAgent/agent";
import { exec } from "child_process";

export default function useQuickPentestAgent() {
  const [target, setTarget] = useState("");
  const [objective, setObjective] = useState("");
  const [messages, setMessages] = useState<Message[]>([]);
  const [hasStarted, setHasStarted] = useState(false);
  const [isCompleted, setIsCompleted] = useState(false);
  const [sessionPath, setSessionPath] = useState<string>("");
  const [abortController, setAbortController] =
    useState<AbortController | null>(null);

  const {
    model,
    addTokens,
    setTokenCount,
    setThinking,
    isExecuting,
    setIsExecuting,
  } = useAgent();

  function openReport() {
    if (sessionPath) {
      const reportPath = `${sessionPath}/pentest-report.md`;
      // Open the report in the default editor
      exec(`open "${reportPath}"`, (error) => {
        if (error) {
          console.error("Error opening report:", error);
        }
      });
    }
  }

  async function beginExecution() {
    if (target && objective && !hasStarted) {
      setHasStarted(true);
      setThinking(true);
      setIsExecuting(true);

      // Create new abort controller for this execution
      const controller = new AbortController();
      setAbortController(controller);

      try {
        const result = runAgent({
          target,
          objective,
          model: model.id,
          abortSignal: controller.signal,
          onStepFinish: ({ usage }) => {
            // Track actual tokens from each step including tool calls
            const stepTokens =
              (usage.inputTokens ?? 0) + (usage.outputTokens ?? 0);
            setTokenCount(stepTokens);
          },
        });

        // Store session path for display
        setSessionPath(result.session.rootPath);

        // Add initial user message
        const userMessage: Message = {
          role: "user",
          content: `Target: ${target}\nObjective: ${objective}\n\nSession: ${result.session.id}\nPath: ${result.session.rootPath}`,
          createdAt: new Date(),
        };

        const allMessages: Message[] = [userMessage];
        let currentAssistantText = "";

        // Consume the full stream including text, tool calls, and tool results
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            // Accumulate text for the current assistant message
            currentAssistantText += delta.text;
            addTokens(1);

            // Update or create the current assistant message
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              allMessages[allMessages.length - 1] = {
                ...lastMessage,
                content: currentAssistantText,
              };
            } else {
              // Create new assistant message
              allMessages.push({
                role: "assistant",
                content: currentAssistantText,
                createdAt: new Date(),
              });
            }

            setMessages([...allMessages]);
          } else if (delta.type === "tool-call") {
            // Finalize current assistant text if any
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            setThinking(false);

            // Add tool call as a pending message with toolCallId
            const toolName = delta.toolName;
            allMessages.push({
              role: "tool",
              status: "pending",
              toolCallId: delta.toolCallId,
              content: delta.input.toolCallDescription
                ? `${delta.input.toolCallDescription}`
                : `Calling tool: ${toolName}`,
              args: delta.input,
              toolName,
              createdAt: new Date(),
            });

            setMessages([...allMessages]);
          } else if (delta.type === "tool-result") {
            setThinking(true);

            // Find and update the existing tool message by toolCallId
            const toolName = delta.toolName;
            const existingToolMessageIndex = allMessages.findIndex(
              (msg) =>
                msg.role === "tool" &&
                (msg as ToolMessage).toolCallId === delta.toolCallId
            );

            if (existingToolMessageIndex !== -1) {
              const existingMessage = allMessages[
                existingToolMessageIndex
              ] as ToolMessage;
              allMessages[existingToolMessageIndex] = {
                ...existingMessage,
                status: "completed",
                content: delta.input.toolCallDescription
                  ? `✓ ${delta.input.toolCallDescription}`
                  : `✓ Tool ${toolName}`,
                toolName: toolName,
                args: delta.input,
              };
            }

            setMessages([...allMessages]);
          }
          saveMessages(result.session, allMessages);
        }

        if (fs.existsSync(result.session.rootPath + "/pentest-report.md")) {
          setIsCompleted(true);
        }

        setThinking(false);
        setIsExecuting(false);
      } catch (error) {
        console.error("Error during agent execution:", error);
        setThinking(false);
        setIsExecuting(false);

        // Check if this was an abort
        if (error instanceof Error && error.name === "AbortError") {
          const abortMessage: Message = {
            role: "assistant",
            content: "⚠️ Execution aborted by user",
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, abortMessage]);
        } else {
          const errorMessage: Message = {
            role: "assistant",
            content: `Error: ${
              error instanceof Error ? error.message : "Unknown error occurred"
            }`,
            createdAt: new Date(),
          };
          setMessages((prev) => [...prev, errorMessage]);
        }
      }
    }
  }

  return {
    target,
    setTarget,
    objective,
    setObjective,
    messages,
    setMessages,
    hasStarted,
    setHasStarted,
    isCompleted,
    setIsCompleted,
    sessionPath,
    abortController,
    isExecuting,
    beginExecution,
    openReport,
  };
}
