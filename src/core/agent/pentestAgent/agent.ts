import {
  stepCountIs,
  type StreamTextResult,
  type ToolSet,
  type StreamTextOnStepFinishCallback,
  hasToolCall,
  tool,
} from "ai";
import { streamResponse, type AIModel } from "../../ai";
import { SYSTEM } from "./prompts";
import {
  createPentestTools,
  type ExecuteCommandOpts,
  type ExecuteCommandResult,
  type HttpRequestOpts,
  type HttpRequestResult,
} from "../tools";
import { createSession, type Session } from "../sessions";
import { detectOSAndEnhancePrompt } from "../utils";
import { z } from "zod";
import { join } from "path";
import {
  writeFileSync,
  appendFileSync,
  existsSync,
  mkdirSync,
  chmodSync,
  unlinkSync,
} from "fs";
import { exec } from "child_process";
import { promisify } from "util";
import { documentFindingAgent } from "../documentFindingAgent.ts/agent";
import type { AIAuthConfig } from "../../ai/utils";
import type {
  CreatePocOpts,
  CreatePocResult,
  DocumentFindingResult,
  Finding,
} from "../documentFindingAgent.ts";

const execAsync = promisify(exec);

export interface RunAgentProps {
  target: string;
  objective: string;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  session?: Session;
  silent?: boolean;
  authConfig?: AIAuthConfig;
  toolOverride?: {
    create_poc?: (opts: CreatePocOpts) => Promise<CreatePocResult>;
    execute_command?: (
      opts: ExecuteCommandOpts
    ) => Promise<ExecuteCommandResult>;
    http_request?: (opts: HttpRequestOpts) => Promise<HttpRequestResult>;
  };
}

export interface RunAgentResult extends StreamTextResult<ToolSet, never> {
  session: Session;
}

/**
 * Executes the penetration testing agent with configurable tool overrides.
 *
 * This function orchestrates a full penetration testing workflow including:
 * - Session management and directory creation
 * - Tool initialization with optional sandbox-compatible overrides
 * - Intelligent sub-agent for finding documentation
 * - Streaming AI-powered testing execution
 *
 * ## Tool Overrides
 *
 * The `toolOverride` parameter allows replacing local execution tools with sandbox-compatible
 * implementations. This is essential when running the agent in containerized or remote environments
 * where direct system access is not available or desired.
 *
 * ### Overridable Tools
 *
 * 1. **`execute_command`** - Executes shell commands
 *    - Local: Runs commands directly on the host system via Node's `child_process`
 *    - Sandbox: Should execute commands in a Docker container, VM, or remote environment
 *    - Implementation requirement: Must return `Promise<ExecuteCommandResult>` with:
 *      - `success: boolean` - Whether command executed successfully
 *      - `stdout: string` - Standard output from the command
 *      - `stderr: string` - Standard error from the command
 *      - `exitCode: number` - Command exit code
 *    - Example: Replace with Docker exec, SSH remote execution, or API-based command runner
 *
 * 2. **`http_request`** - Makes HTTP requests to test endpoints
 *    - Local: Uses Node's HTTP client to make requests from the host machine
 *    - Sandbox: Should make requests from within the sandbox environment
 *    - Implementation requirement: Must return `Promise<HttpRequestResult>` with:
 *      - `success: boolean` - Whether request completed
 *      - `statusCode: number` - HTTP status code
 *      - `headers: Record<string, string>` - Response headers
 *      - `body: string` - Response body
 *    - Example: Replace with containerized HTTP client or proxied requests
 *
 * 3. **`create_poc`** - Creates and executes proof-of-concept scripts
 *    - Local: Creates files on local filesystem and executes them directly
 *    - Sandbox: Should create and execute POCs within isolated environment
 *    - Implementation requirement: Must return `Promise<CreatePocResult>` with:
 *      - `success: boolean` - Whether POC was created and executed
 *      - `pocPath: string` - Path where POC script was saved
 *      - `executionOutput: string` - Output from running the POC
 *      - `error?: string` - Error message if POC failed
 *    - Example: Replace with sandbox file creation and isolated script execution
 *
 * ### Override Propagation
 *
 * Tool overrides are automatically propagated to:
 * - `createPentestTools()` - Base pentesting tools
 * - `documentFindingAgent()` - Sub-agent for finding documentation and POC creation
 *
 * This ensures consistent execution environment across all agent operations.
 *
 * @param opts - Configuration options for the agent
 * @param opts.target - The target URL or system to test (e.g., "https://example.com")
 * @param opts.objective - The testing objective or specific vulnerability to search for
 * @param opts.model - The AI model to use for agent reasoning
 * @param opts.onStepFinish - Optional callback fired after each agent step completes
 * @param opts.abortSignal - Optional signal to abort the agent execution
 * @param opts.session - Optional existing session to continue (creates new if not provided)
 * @param opts.silent - Whether to suppress console output
 * @param opts.authConfig - Optional authentication configuration for AI API
 * @param opts.toolOverride - Optional sandbox-compatible tool implementations
 *
 * @returns Object containing the streaming result and session
 * @returns streamResult - The AI stream result with all tool outputs
 * @returns session - The testing session containing findings, POCs, and metadata
 */
export function runAgent(opts: RunAgentProps): {
  streamResult: RunAgentResult;
  session: Session;
} {
  const {
    target,
    objective,
    model,
    onStepFinish,
    abortSignal,
    silent,
    authConfig,
    toolOverride,
  } = opts;

  // Create a new session for this pentest run
  const session = opts.session || createSession(target, objective);

  // Create pocs directory for pentest agent
  const pocsPath = join(session.rootPath, "pocs");
  if (!existsSync(pocsPath)) {
    mkdirSync(pocsPath, { recursive: true });
  }

  // Create tools with session context
  const {
    execute_command,
    http_request,
    analyze_scan,
    scratchpad,
    generate_report,
  } = createPentestTools(session, undefined, toolOverride);

  // Pentest-specific tool: document_finding with POC validation
  const document_finding = tool({
    name: "document_finding",
    description: `Document a security finding with severity, impact, and remediation guidance.

**CRITICAL REQUIREMENT:** You MUST provide a valid POC path. The POC script must exist before documenting.

WORKFLOW:
1. Discover potential vulnerability
2. Use create_poc tool to create and test the POC script
3. Review create_poc execution output to confirm vulnerability
4. Call document_finding with the POC path from create_poc
5. If POC doesn't exist, you'll get an error - use create_poc first, then retry

**RECOMMENDED:** Use create_poc tool to create POCs - it automatically tests them and reports output.

SEVERITY LEVELS:
- CRITICAL: Immediate risk of system compromise (RCE, auth bypass, SQL injection with data access)
- HIGH: Significant security risk (XSS, CSRF, sensitive data exposure, privilege escalation)
- MEDIUM: Security weakness that could be exploited (information disclosure, weak configs)
- LOW: Minor security concern (missing headers, verbose errors)

FINDING STRUCTURE:
- Title: Clear, concise description
- Severity: Use CVSS if applicable
- Description: Detailed technical explanation
- Impact: Business and technical consequences
- Evidence: Commands run, responses received, proof of vulnerability
- Endpoint: The full URL Endpoint of the finding. Do not include any other text. i.e. https://example.com/endpoint. If this is an application wide vulnerability, consider it apart of the root path i.e. https://example.com/
- POC Path: Path to the proof-of-concept script (REQUIRED)
- Remediation: Specific, actionable steps to fix
- References: CVE, CWE, OWASP, or security advisories`,
    inputSchema: z.object({
      title: z.string().describe("Finding title"),
      severity: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
      description: z.string().describe("Detailed description of the finding"),
      impact: z.string().describe("Potential impact if exploited"),
      evidence: z.string().describe("Evidence/proof of the vulnerability"),
      remediation: z.string().describe("Steps to fix the issue"),
      endpoint: z
        .string()
        .describe(
          "ONLY the full URL Endpoint of the finding. Do not include any other text. i.e. https://example.com/endpoint"
        ),
      references: z
        .string()
        .optional()
        .describe("CVE, CWE, or related references"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async (finding) => {
      try {
        // Validate POC path exists
        const streamResult = await documentFindingAgent(
          finding,
          model,
          session,
          authConfig,
          toolOverride,
          onStepFinish
        );

        return {
          success: true,
          result: streamResult,
          message: `Finding documented with POC: [${finding.severity}] ${finding.title}`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to document finding: ${error.message}`,
        };
      }
    },
  });

  // Build the enhanced prompt with target context
  const enhancedPrompt = `
TARGET: ${target}
OBJECTIVE: ${objective}

Session Information:
- Session ID: ${session.id}
- Findings will be saved to: ${session.findingsPath}
- POCs will be automatically created in: ${pocsPath}
- Use the scratchpad tool for notes and observations

**IMPORTANT: document_finding is now an INTELLIGENT SUB-AGENT**

The document_finding tool spawns a specialized agent that handles:
- Duplicate detection (prevents documenting same finding twice)
- POC creation (automatically creates bash or HTML POCs)
- POC testing and iteration (retries up to 3 times if POC fails)
- Finding documentation (only if unique and POC works)

Begin your penetration test by:
1. Quick target analysis (understand technology stack)
2. Focused testing based on objective
3. For each vulnerability discovered:
   a. Thoroughly test the vulnerability
   b. Gather detailed evidence (commands, responses, observations)
   c. Call document_finding with all finding details
      - Provide: title, severity, description, impact, evidence, remediation
      - The sub-agent automatically creates and tests POC
      - The sub-agent checks for duplicates
      - The sub-agent documents if unique and POC works
   d. Review the response:
      - ✅ "Finding documented" → Success, continue testing
      - ❌ "Discarded - duplicate" → Already documented, continue testing
      - ❌ "Discarded - no POC" → Not confirmed, continue testing
4. Use scratchpad to track your progress

**SIMPLIFIED WORKFLOW:**
- Test vulnerability → Gather evidence → Call document_finding → Move on
- You DON'T create POCs manually
- You DON'T check for duplicates manually
- You DON'T test POCs manually
- The document_finding agent does ALL of that for you

**BENEFITS:**
- Cleaner workflow - just focus on testing
- No duplicate findings automatically
- All findings have verified POCs
- Automatic POC creation and testing
- Quality control built-in

Remember to follow a systematic methodology and explain your reasoning for each test you perform.

## IMPORTANT REMINDER:
You are only authorized to perform testing against the specific target endpoint provided to you. Do not discover other services or enumberate other endpoints not defined in the TARGET. If the target is a root path, you should not enumerate other endpoints.
`.trim();

  const systemPrompt = detectOSAndEnhancePrompt(SYSTEM);

  const streamResult = streamResponse({
    prompt: enhancedPrompt,
    system: systemPrompt,
    model,
    tools: {
      execute_command,
      http_request,
      analyze_scan,
      document_finding,
      scratchpad,
      generate_report,
    },
    stopWhen: stepCountIs(10000),
    toolChoice: "auto",
    onStepFinish,
    abortSignal,
    silent,
    authConfig,
  });

  // Attach the session directly to the stream result object
  (streamResult as any).session = session;

  return { streamResult: streamResult as RunAgentResult, session };
}
