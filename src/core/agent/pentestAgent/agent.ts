import {
  stepCountIs,
  type StreamTextResult,
  type ToolSet,
  type StreamTextOnStepFinishCallback,
  hasToolCall,
  tool,
} from "ai";
import { streamResponse, type AIModel } from "../../ai";
import { SYSTEM } from "./prompts";
import { createPentestTools } from "../tools";
import { createSession, type Session } from "../sessions";
import { detectOSAndEnhancePrompt } from "../utils";
import { z } from "zod";
import { join } from "path";
import {
  writeFileSync,
  appendFileSync,
  existsSync,
  mkdirSync,
  chmodSync,
  unlinkSync,
} from "fs";
import { exec } from "child_process";
import { promisify } from "util";
import { documentFindingAgent } from "../documentFindingAgent.ts/agent";
import type { AIAuthConfig } from "../../ai/utils";

const execAsync = promisify(exec);

export interface RunAgentProps {
  target: string;
  objective: string;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  session?: Session;
  silent?: boolean;
  authConfig?: AIAuthConfig;
}

export interface RunAgentResult extends StreamTextResult<ToolSet, never> {
  session: Session;
}

export async function runAgent(opts: RunAgentProps): Promise<{
  streamResult: RunAgentResult;
  session: Session;
}> {
  const {
    target,
    objective,
    model,
    onStepFinish,
    abortSignal,
    silent,
    authConfig,
  } = opts;

  // Create a new session for this pentest run

  // TODO: may need to test if this logic can be exploited to bypass dns ownership check
  // We don't really care if someone forks this and comments it out, but I'm more worried
  // about potential prompt injection or the agent using malformed inputs
  // We could move the dns ownership check outside of the session logic and move it here so even every sub agent must run a check
  const session = opts.session || (await createSession(target, objective));

  // Create pocs directory for pentest agent
  const pocsPath = join(session.rootPath, "pocs");
  if (!existsSync(pocsPath)) {
    mkdirSync(pocsPath, { recursive: true });
  }

  // Create tools with session context
  const {
    execute_command,
    http_request,
    analyze_scan,
    scratchpad,
    generate_report,
  } = createPentestTools(session);

  // Pentest-specific tool: document_finding with POC validation
  const document_finding = tool({
    name: "document_finding",
    description: `Document a security finding with severity, impact, and remediation guidance.

**CRITICAL REQUIREMENT:** You MUST provide a valid POC path. The POC script must exist before documenting.

WORKFLOW:
1. Discover potential vulnerability
2. Use create_poc tool to create and test the POC script
3. Review create_poc execution output to confirm vulnerability
4. Call document_finding with the POC path from create_poc
5. If POC doesn't exist, you'll get an error - use create_poc first, then retry

**RECOMMENDED:** Use create_poc tool to create POCs - it automatically tests them and reports output.

SEVERITY LEVELS:
- CRITICAL: Immediate risk of system compromise (RCE, auth bypass, SQL injection with data access)
- HIGH: Significant security risk (XSS, CSRF, sensitive data exposure, privilege escalation)
- MEDIUM: Security weakness that could be exploited (information disclosure, weak configs)
- LOW: Minor security concern (missing headers, verbose errors)

FINDING STRUCTURE:
- Title: Clear, concise description
- Severity: Use CVSS if applicable
- Description: Detailed technical explanation
- Impact: Business and technical consequences
- Evidence: Commands run, responses received, proof of vulnerability
- POC Path: Path to the proof-of-concept script (REQUIRED)
- Remediation: Specific, actionable steps to fix
- References: CVE, CWE, OWASP, or security advisories`,
    inputSchema: z.object({
      title: z.string().describe("Finding title"),
      severity: z.enum(["CRITICAL", "HIGH", "MEDIUM", "LOW"]),
      description: z.string().describe("Detailed description of the finding"),
      impact: z.string().describe("Potential impact if exploited"),
      evidence: z.string().describe("Evidence/proof of the vulnerability"),
      remediation: z.string().describe("Steps to fix the issue"),
      references: z
        .string()
        .optional()
        .describe("CVE, CWE, or related references"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async (finding) => {
      try {
        // Validate POC path exists
        const streamResult = await documentFindingAgent(
          finding,
          model,
          session,
          authConfig
        );

        return {
          success: true,
          result: streamResult,
          message: `Finding documented with POC: [${finding.severity}] ${finding.title}`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to document finding: ${error.message}`,
        };
      }
    },
  });

  // Build the enhanced prompt with target context
  const enhancedPrompt = `
TARGET: ${target}
OBJECTIVE: ${objective}

Session Information:
- Session ID: ${session.id}
- Findings will be saved to: ${session.findingsPath}
- POCs will be automatically created in: ${pocsPath}
- Use the scratchpad tool for notes and observations

**IMPORTANT: document_finding is now an INTELLIGENT SUB-AGENT**

The document_finding tool spawns a specialized agent that handles:
- Duplicate detection (prevents documenting same finding twice)
- POC creation (automatically creates bash or HTML POCs)
- POC testing and iteration (retries up to 3 times if POC fails)
- Finding documentation (only if unique and POC works)

Begin your penetration test by:
1. Quick target analysis (understand technology stack)
2. Focused testing based on objective
3. For each vulnerability discovered:
   a. Thoroughly test the vulnerability
   b. Gather detailed evidence (commands, responses, observations)
   c. Call document_finding with all finding details
      - Provide: title, severity, description, impact, evidence, remediation
      - The sub-agent automatically creates and tests POC
      - The sub-agent checks for duplicates
      - The sub-agent documents if unique and POC works
   d. Review the response:
      - ✅ "Finding documented" → Success, continue testing
      - ❌ "Discarded - duplicate" → Already documented, continue testing
      - ❌ "Discarded - no POC" → Not confirmed, continue testing
4. Use scratchpad to track your progress

**SIMPLIFIED WORKFLOW:**
- Test vulnerability → Gather evidence → Call document_finding → Move on
- You DON'T create POCs manually
- You DON'T check for duplicates manually
- You DON'T test POCs manually
- The document_finding agent does ALL of that for you

**BENEFITS:**
- Cleaner workflow - just focus on testing
- No duplicate findings automatically
- All findings have verified POCs
- Automatic POC creation and testing
- Quality control built-in

Remember to follow a systematic methodology and explain your reasoning for each test you perform.
`.trim();

  const systemPrompt = detectOSAndEnhancePrompt(SYSTEM);

  const streamResult = streamResponse({
    prompt: enhancedPrompt,
    system: systemPrompt,
    model,
    tools: {
      execute_command,
      http_request,
      analyze_scan,
      document_finding,
      scratchpad,
      generate_report,
    },
    stopWhen: stepCountIs(10000),
    toolChoice: "auto", // Let the model decide when to use tools vs respond
    onStepFinish,
    abortSignal,
    silent,
    authConfig,
  });

  // Attach the session directly to the stream result object
  (streamResult as any).session = session;

  return { streamResult: streamResult as RunAgentResult, session };
}
