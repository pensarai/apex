import {
  stepCountIs,
  type StreamTextResult,
  type ToolSet,
  type StreamTextOnStepFinishCallback,
  tool,
  type ModelMessage,
  hasToolCall,
} from "ai";
import { streamResponse, type AIModel } from "../../ai";
import { SYSTEM } from "./prompts";
import { createSession, type Session } from "../sessions";
import { z } from "zod";
import { join } from "path";
import { readFileSync, existsSync, writeFileSync } from "fs";
import { runAgent as runAttackSurfaceAgent } from "../attackSurfaceAgent/agent";
import { runAgent as runPentestAgent } from "../pentestAgent/agent";
import type { AttackSurfaceAnalysisResults } from "../attackSurfaceAgent/types";
import {
  saveSubagentMessages,
  type Message,
  type ToolMessage,
} from "../../messages";
import { Logger } from "../logger";
import { detectOSAndEnhancePrompt } from "../utils";

export interface SubagentSpawnInfo {
  id: string;
  name: string;
  type: "attack-surface" | "pentest";
  target: string;
}

export interface RunAgentProps {
  target: string;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
  onSubagentSpawn?: (info: SubagentSpawnInfo) => void;
  onSubagentMessage?: (subagentId: string, message: Message) => void;
  onSubagentComplete?: (subagentId: string, success: boolean) => void;
}

export interface RunAgentResult extends StreamTextResult<ToolSet, never> {
  session: Session;
}

export function runAgent(opts: RunAgentProps): {
  streamResult: RunAgentResult;
  session: Session;
} {
  const {
    target,
    model,
    onStepFinish,
    abortSignal,
    onSubagentSpawn,
    onSubagentMessage,
    onSubagentComplete,
  } = opts;
  const session = createSession(target);

  const logger = new Logger(session);

  // Create a new session for this thorough pentest
  logger.log(`Created thorough pentest session: ${session.id}`);
  logger.log(`Session path: ${session.rootPath}`);

  // Create orchestrator-specific tools
  const tools = createOrchestratorTools(
    session,
    model,
    abortSignal,
    onSubagentSpawn,
    onSubagentMessage,
    onSubagentComplete,
    logger
  );

  // Build the enhanced prompt with target context
  const enhancedPrompt = `
TARGET: ${target}

Session Information:
- Session ID: ${session.id}
- Session Path: ${session.rootPath}

You are the ORCHESTRATOR agent for a comprehensive penetration testing engagement.

Your mission:
1. First, run the attack surface agent to discover all assets and identify high-value targets
2. Review the attack surface analysis results
3. Strategically spawn pentest agents for high-value targets identified
4. Monitor and coordinate all sub-agent activities
5. Generate a comprehensive final report combining all findings

Begin by using the get_attack_surface tool to map the complete attack surface of the target.
`.trim();

  const systemPrompt = detectOSAndEnhancePrompt(SYSTEM);

  const streamResult = streamResponse({
    prompt: enhancedPrompt,
    system: systemPrompt,
    model,
    tools,
    stopWhen: stepCountIs(10000),
    toolChoice: "auto",
    onStepFinish,
    abortSignal,
  });

  // Attach the session directly to the stream result object
  (streamResult as any).session = session;

  return { streamResult: streamResult as RunAgentResult, session };
}

/**
 * Create tools specific to the orchestrator agent
 */
function createOrchestratorTools(
  session: Session,
  model: AIModel,
  abortSignal?: AbortSignal,
  onSubagentSpawn?: (info: SubagentSpawnInfo) => void,
  onSubagentMessage?: (subagentId: string, message: Message) => void,
  onSubagentComplete?: (subagentId: string, success: boolean) => void,
  logger?: Logger
) {
  // Tool to run attack surface agent
  const getAttackSurface = tool({
    name: "get_attack_surface",
    description: `Run the attack surface analysis agent to discover all assets and identify targets.
    
This tool spawns a specialized reconnaissance agent that will:
- Map all domains, subdomains, IPs, and services
- Identify web applications, APIs, and cloud resources
- Categorize assets by type and risk level
- Identify high-value targets for deep penetration testing
- Return structured results with recommended testing objectives

The agent operates autonomously and will return comprehensive results including:
- Complete asset inventory
- High-value targets with suggested objectives
- Key findings from reconnaissance
- Recommended testing priorities

Use this as the FIRST step in your thorough penetration test.`,
    inputSchema: z.object({
      target: z.string().describe("The target to analyze (domain, IP, or URL)"),
      objective: z
        .string()
        .describe("Specific focus areas for attack surface analysis"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ target, objective }) => {
      try {
        logger?.log(
          `[Orchestrator] Spawning attack surface agent for: ${target}`
        );

        // Run the attack surface agent
        const { streamResult: result } = runAttackSurfaceAgent({
          session,
          target,
          objective,
          model,
          abortSignal,
        });

        const subagentId = `attack-surface-${result.session.id}`;
        const allMessages: Message[] = [];
        let currentAssistantText = "";

        // Notify about subagent spawn
        if (onSubagentSpawn) {
          onSubagentSpawn({
            id: subagentId,
            name: `Attack Surface Analysis: ${target}`,
            type: "attack-surface",
            target,
          });
        }

        // Add initial user message
        const initialMessage: Message = {
          role: "user",
          content: `Target: ${target}\nObjective: ${objective}`,
          createdAt: new Date(),
        };
        allMessages.push(initialMessage);

        // Send initial message to UI
        if (onSubagentMessage) {
          onSubagentMessage(subagentId, initialMessage);
        }

        // Consume the stream and capture messages
        for await (const delta of result.fullStream) {
          if (delta.type === "text-delta") {
            currentAssistantText += delta.text;
            const lastMessage = allMessages[allMessages.length - 1];

            if (lastMessage && lastMessage.role === "assistant") {
              lastMessage.content = currentAssistantText;
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, lastMessage);
              }
            } else {
              const newMessage: Message = {
                role: "assistant",
                content: currentAssistantText,
                createdAt: new Date(),
              };
              allMessages.push(newMessage);
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, newMessage);
              }
            }
          } else if (delta.type === "tool-call") {
            if (currentAssistantText) {
              currentAssistantText = "";
            }

            const toolMessage: Message = {
              role: "tool",
              status: "pending",
              toolCallId: delta.toolCallId,
              content:
                delta.input.toolCallDescription || `Calling ${delta.toolName}`,
              args: delta.input,
              toolName: delta.toolName,
              createdAt: new Date(),
            };
            allMessages.push(toolMessage);
            if (onSubagentMessage) {
              onSubagentMessage(subagentId, toolMessage);
            }
          } else if (delta.type === "tool-result") {
            const existingToolMessageIndex = allMessages.findIndex(
              (msg) =>
                msg.role === "tool" &&
                (msg as ToolMessage).toolCallId === delta.toolCallId
            );

            if (existingToolMessageIndex !== -1) {
              const existingMessage = allMessages[
                existingToolMessageIndex
              ] as ToolMessage;
              existingMessage.status = "completed";
              existingMessage.content = delta.input.toolCallDescription
                ? `✓ ${delta.input.toolCallDescription}`
                : `✓ Tool ${delta.toolName}`;
              if (onSubagentMessage) {
                onSubagentMessage(subagentId, existingMessage);
              }
            }
          }
        }

        // Notify completion
        if (onSubagentComplete) {
          onSubagentComplete(subagentId, true);
        }

        // Save subagent messages to orchestrator session
        saveSubagentMessages(session, subagentId, allMessages);

        // Save subagent metadata
        const subagentMetadata = {
          type: "attack-surface",
          subagentId,
          target,
          objective,
          sessionId: result.session.id,
          sessionPath: result.session.rootPath,
          startTime: new Date().toISOString(),
          endTime: new Date().toISOString(),
        };

        writeFileSync(
          join(session.rootPath, "subagents", subagentId, "metadata.json"),
          JSON.stringify(subagentMetadata, null, 2)
        );

        // Read the results file
        const resultsPath = join(
          result.session.rootPath,
          "attack-surface-results.json"
        );

        if (existsSync(resultsPath)) {
          const resultsData = readFileSync(resultsPath, "utf-8");
          const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

          return {
            success: true,
            sessionId: result.session.id,
            sessionPath: result.session.rootPath,
            subagentId,
            resultsPath,
            summary: results.summary,
            targets: results.targets,
            message: `Attack surface analysis complete. Discovered ${results.summary.totalAssets} assets with ${results.summary.highValueTargets} high-value targets identified for penetration testing. Subagent messages saved to subagents/${subagentId}/`,
          };
        } else {
          // Notify failure
          if (onSubagentComplete) {
            onSubagentComplete(subagentId, false);
          }
          logger?.error(
            `[Orchestrator] Attack surface agent did not produce results file`
          );

          return {
            success: false,
            sessionId: result.session.id,
            sessionPath: result.session.rootPath,
            subagentId,
            error: "Attack surface agent did not produce results file",
            message:
              "The attack surface agent completed but did not generate the expected results. Check the session logs.",
          };
        }
      } catch (error: any) {
        // Notify failure if subagent was spawned
        logger?.error(
          `[Orchestrator] Failed to run attack surface agent: ${error.message}`
        );
        if (onSubagentComplete) {
          const subagentId = `attack-surface-failed`;
          onSubagentComplete(subagentId, false);
        }

        return {
          success: false,
          error: error.message,
          message: `Failed to run attack surface agent: ${error.message}`,
        };
      }
    },
  });

  // Tool to run pentest agents for specific targets
  const runPentestAgents = tool({
    name: "run_pentest_agents",
    description: `Spawn penetration testing agents for specific targets.
    
This tool runs specialized penetration testing agents that will:
- Perform deep security testing on specific targets
- Test for common web vulnerabilities (SQLi, XSS, CSRF, etc.)
- Analyze authentication and authorization mechanisms
- Check for misconfigurations and exposures
- Generate detailed findings with severity ratings
- Create comprehensive penetration testing reports

Each agent operates autonomously and performs thorough black-box testing.

Use this tool AFTER reviewing attack surface results to test high-value targets.
You can spawn multiple agents in parallel - they will run concurrently.`,
    inputSchema: z.object({
      targets: z
        .array(
          z.object({
            target: z
              .string()
              .describe("The target to pentest (URL, IP, or domain)"),
            objective: z
              .string()
              .describe(
                "Specific penetration testing objective for this target"
              ),
          })
        )
        .describe(
          "Array of targets to pentest (recommended: 3-10 high-priority targets)"
        ),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ targets }) => {
      try {
        logger?.log(
          `[Orchestrator] Spawning ${targets.length} pentest agents...`
        );

        // Launch all pentest agents in parallel
        const promises = targets.map(async (targetInfo, index) => {
          try {
            const { streamResult: result } = runPentestAgent({
              session,
              target: targetInfo.target,
              objective: targetInfo.objective,
              model,
              abortSignal,
            });

            const subagentId = `pentest-${index + 1}-${result.session.id}`;
            const allMessages: Message[] = [];
            let currentAssistantText = "";
            const startTime = new Date().toISOString();

            // Notify about subagent spawn
            if (onSubagentSpawn) {
              onSubagentSpawn({
                id: subagentId,
                name: `Pentest ${index + 1}: ${targetInfo.target}`,
                type: "pentest",
                target: targetInfo.target,
              });
            }

            // Add initial user message
            const initialMessage: Message = {
              role: "user",
              content: `Target: ${targetInfo.target}\nObjective: ${targetInfo.objective}`,
              createdAt: new Date(),
            };
            allMessages.push(initialMessage);

            // Send initial message to UI
            if (onSubagentMessage) {
              onSubagentMessage(subagentId, initialMessage);
            }

            // Consume the stream and capture messages
            for await (const delta of result.fullStream) {
              if (delta.type === "text-delta") {
                currentAssistantText += delta.text;
                const lastMessage = allMessages[allMessages.length - 1];

                if (lastMessage && lastMessage.role === "assistant") {
                  lastMessage.content = currentAssistantText;
                  if (onSubagentMessage) {
                    onSubagentMessage(subagentId, lastMessage);
                  }
                } else {
                  const newMessage: Message = {
                    role: "assistant",
                    content: currentAssistantText,
                    createdAt: new Date(),
                  };
                  allMessages.push(newMessage);
                  if (onSubagentMessage) {
                    onSubagentMessage(subagentId, newMessage);
                  }
                }
              } else if (delta.type === "tool-call") {
                if (currentAssistantText) {
                  currentAssistantText = "";
                }

                const toolMessage: Message = {
                  role: "tool",
                  status: "pending",
                  toolCallId: delta.toolCallId,
                  content:
                    delta.input.toolCallDescription ||
                    `Calling ${delta.toolName}`,
                  args: delta.input,
                  toolName: delta.toolName,
                  createdAt: new Date(),
                };
                allMessages.push(toolMessage);
                if (onSubagentMessage) {
                  onSubagentMessage(subagentId, toolMessage);
                }
              } else if (delta.type === "tool-result") {
                const existingToolMessageIndex = allMessages.findIndex(
                  (msg) =>
                    msg.role === "tool" &&
                    (msg as ToolMessage).toolCallId === delta.toolCallId
                );

                if (existingToolMessageIndex !== -1) {
                  const existingMessage = allMessages[
                    existingToolMessageIndex
                  ] as ToolMessage;
                  existingMessage.status = "completed";
                  existingMessage.content = delta.input.toolCallDescription
                    ? `✓ ${delta.input.toolCallDescription}`
                    : `✓ Tool ${delta.toolName}`;
                  if (onSubagentMessage) {
                    onSubagentMessage(subagentId, existingMessage);
                  }
                }
              }
            }

            const endTime = new Date().toISOString();

            // Notify completion
            if (onSubagentComplete) {
              onSubagentComplete(subagentId, true);
            }

            // Save subagent messages to orchestrator session
            saveSubagentMessages(session, subagentId, allMessages);

            // Save subagent metadata
            const subagentMetadata = {
              type: "pentest",
              subagentId,
              target: targetInfo.target,
              objective: targetInfo.objective,
              sessionId: result.session.id,
              sessionPath: result.session.rootPath,
              startTime,
              endTime,
              agentIndex: index + 1,
            };

            writeFileSync(
              join(session.rootPath, "subagents", subagentId, "metadata.json"),
              JSON.stringify(subagentMetadata, null, 2)
            );

            return {
              target: targetInfo.target,
              success: true,
              sessionId: result.session.id,
              sessionPath: result.session.rootPath,
              subagentId,
            };
          } catch (error: any) {
            const subagentId = `pentest-${index + 1}-failed`;
            logger?.error(
              `[Orchestrator] Failed to run pentest agent: ${error.message}`
            );
            // Notify failure
            if (onSubagentComplete) {
              onSubagentComplete(subagentId, false);
            }

            return {
              target: targetInfo.target,
              success: false,
              error: error.message,
            };
          }
        });

        const results = await Promise.all(promises);
        const successful = results.filter((r) => r.success).length;
        const failed = results.filter((r) => !r.success).length;

        return {
          success: true,
          totalAgents: targets.length,
          successful,
          failed,
          results,
          message: `Launched ${
            targets.length
          } pentest agents. ${successful} completed successfully${
            failed > 0 ? `, ${failed} failed` : ""
          }. All subagent messages saved to subagents/ directory.`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to spawn pentest agents: ${error.message}`,
        };
      }
    },
  });

  // Tool to read attack surface results
  const readAttackSurfaceResults = tool({
    name: "read_attack_surface_results",
    description: `Read the structured results from a completed attack surface analysis.
    
Use this after running get_attack_surface to review:
- Complete asset inventory
- High-value targets with objectives
- Key findings and exposures
- Recommended testing priorities

This helps you decide which targets to send to pentest agents.`,
    inputSchema: z.object({
      sessionPath: z
        .string()
        .describe("Path to the attack surface agent session"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ sessionPath }) => {
      try {
        const resultsPath = join(sessionPath, "attack-surface-results.json");

        if (!existsSync(resultsPath)) {
          return {
            success: false,
            error: "Results file not found",
            message: `No results file found at ${resultsPath}`,
          };
        }

        const resultsData = readFileSync(resultsPath, "utf-8");
        const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

        return {
          success: true,
          results,
          message: `Loaded attack surface results: ${results.summary.totalAssets} assets, ${results.summary.highValueTargets} high-value targets`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to read results: ${error.message}`,
        };
      }
    },
  });

  // Tool to generate final orchestration report
  const generateFinalReport = tool({
    name: "generate_final_report",
    description: `Generate the final comprehensive report for the entire thorough penetration test.
    
This creates a master report that combines:
- Attack surface analysis findings
- All pentest agent findings
- Overall risk assessment
- Prioritized recommendations
- Executive summary

Use this as the FINAL step after all agents have completed.`,
    inputSchema: z.object({
      executiveSummary: z
        .string()
        .describe("High-level executive summary of the entire engagement"),
      attackSurfaceSessionPath: z
        .string()
        .describe("Path to attack surface agent session"),
      pentestSessionPaths: z
        .array(z.string())
        .describe("Paths to all pentest agent sessions"),
      overallRiskAssessment: z
        .string()
        .describe("Overall risk assessment across all targets"),
      keyFindings: z
        .array(z.string())
        .describe("Most critical findings across all agents"),
      recommendations: z
        .string()
        .describe("Comprehensive recommendations for remediation"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({
      executiveSummary,
      attackSurfaceSessionPath,
      pentestSessionPaths,
      overallRiskAssessment,
      keyFindings,
      recommendations,
    }) => {
      try {
        // This would aggregate all reports - simplified for now
        const report = `# Comprehensive Penetration Testing Report

**Session ID:** ${session.id}
**Target:** ${session.target}
**Objective:** ${session.objective}

## Executive Summary

${executiveSummary}

## Overall Risk Assessment

${overallRiskAssessment}

## Key Findings

${keyFindings.map((finding, idx) => `${idx + 1}. ${finding}`).join("\n")}

## Recommendations

${recommendations}

## Sub-Agent Sessions

### Attack Surface Analysis
- Session: ${attackSurfaceSessionPath}

### Penetration Testing Sessions
${pentestSessionPaths.map((path, idx) => `${idx + 1}. ${path}`).join("\n")}

---

*This report aggregates findings from ${
          pentestSessionPaths.length + 1
        } autonomous security testing agents.*
`;

        const reportPath = join(
          session.rootPath,
          "comprehensive-pentest-report.md"
        );
        require("fs").writeFileSync(reportPath, report);

        return {
          success: true,
          reportPath,
          message: `Comprehensive report generated at ${reportPath}`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to generate report: ${error.message}`,
        };
      }
    },
  });

  return {
    get_attack_surface: getAttackSurface,
    run_pentest_agents: runPentestAgents,
    read_attack_surface_results: readAttackSurfaceResults,
    generate_final_report: generateFinalReport,
  };
}
