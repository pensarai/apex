import {
  stepCountIs,
  type StreamTextResult,
  type ToolSet,
  type StreamTextOnStepFinishCallback,
  tool,
} from "ai";
import { streamResponse, type AIModel } from "../../ai";
import { SYSTEM } from "./prompts";
import { createSession, type Session } from "../sessions";
import { z } from "zod";
import { join } from "path";
import { readFileSync, existsSync } from "fs";
import { runAgent as runAttackSurfaceAgent } from "../attackSurfaceAgent/agent";
import { runAgent as runPentestAgent } from "../pentestAgent/agent";
import type { AttackSurfaceAnalysisResults } from "../attackSurfaceAgent/types";

export interface RunAgentProps {
  target: string;
  objective: string;
  model: AIModel;
  onStepFinish?: StreamTextOnStepFinishCallback<ToolSet>;
  abortSignal?: AbortSignal;
}

export interface RunAgentResult extends StreamTextResult<ToolSet, never> {
  session: Session;
}

export function runAgent(opts: RunAgentProps): RunAgentResult {
  const { target, objective, model, onStepFinish, abortSignal } = opts;

  // Create a new session for this thorough pentest
  const session = createSession(target, objective);

  console.log(`Created thorough pentest session: ${session.id}`);
  console.log(`Session path: ${session.rootPath}`);

  // Create orchestrator-specific tools
  const tools = createOrchestratorTools(session, model, abortSignal);

  // Build the enhanced prompt with target context
  const enhancedPrompt = `
TARGET: ${target}
OBJECTIVE: ${objective}

Session Information:
- Session ID: ${session.id}
- Session Path: ${session.rootPath}

You are the ORCHESTRATOR agent for a comprehensive penetration testing engagement.

Your mission:
1. First, run the attack surface agent to discover all assets and identify high-value targets
2. Review the attack surface analysis results
3. Strategically spawn pentest agents for high-value targets identified
4. Monitor and coordinate all sub-agent activities
5. Generate a comprehensive final report combining all findings

Begin by using the get_attack_surface tool to map the complete attack surface of the target.
`.trim();

  const streamResult = streamResponse({
    prompt: enhancedPrompt,
    system: SYSTEM,
    model,
    tools,
    stopWhen: stepCountIs(10000),
    toolChoice: "auto",
    onStepFinish,
    abortSignal,
  });

  // Attach the session directly to the stream result object
  (streamResult as any).session = session;

  return streamResult as RunAgentResult;
}

/**
 * Create tools specific to the orchestrator agent
 */
function createOrchestratorTools(
  session: Session,
  model: AIModel,
  abortSignal?: AbortSignal
) {
  // Tool to run attack surface agent
  const getAttackSurface = tool({
    name: "get_attack_surface",
    description: `Run the attack surface analysis agent to discover all assets and identify targets.
    
This tool spawns a specialized reconnaissance agent that will:
- Map all domains, subdomains, IPs, and services
- Identify web applications, APIs, and cloud resources
- Categorize assets by type and risk level
- Identify high-value targets for deep penetration testing
- Return structured results with recommended testing objectives

The agent operates autonomously and will return comprehensive results including:
- Complete asset inventory
- High-value targets with suggested objectives
- Key findings from reconnaissance
- Recommended testing priorities

Use this as the FIRST step in your thorough penetration test.`,
    inputSchema: z.object({
      target: z.string().describe("The target to analyze (domain, IP, or URL)"),
      objective: z
        .string()
        .describe("Specific focus areas for attack surface analysis"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ target, objective }) => {
      try {
        console.log(
          `[Orchestrator] Spawning attack surface agent for: ${target}`
        );

        // Run the attack surface agent
        const result = runAttackSurfaceAgent({
          target,
          objective,
          model,
          abortSignal,
        });

        // Consume the stream to completion
        for await (const _delta of result.fullStream) {
          // Just consume the stream, output is handled by the agent itself
        }

        // Read the results file
        const resultsPath = join(
          result.session.rootPath,
          "attack-surface-results.json"
        );

        if (existsSync(resultsPath)) {
          const resultsData = readFileSync(resultsPath, "utf-8");
          const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

          return {
            success: true,
            sessionId: result.session.id,
            sessionPath: result.session.rootPath,
            resultsPath,
            summary: results.summary,
            highValueTargets: results.highValueTargets,
            message: `Attack surface analysis complete. Discovered ${results.summary.totalAssets} assets with ${results.summary.highValueTargets} high-value targets identified for penetration testing.`,
          };
        } else {
          return {
            success: false,
            sessionId: result.session.id,
            sessionPath: result.session.rootPath,
            error: "Attack surface agent did not produce results file",
            message:
              "The attack surface agent completed but did not generate the expected results. Check the session logs.",
          };
        }
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to run attack surface agent: ${error.message}`,
        };
      }
    },
  });

  // Tool to run pentest agents for specific targets
  const runPentestAgents = tool({
    name: "run_pentest_agents",
    description: `Spawn penetration testing agents for specific targets.
    
This tool runs specialized penetration testing agents that will:
- Perform deep security testing on specific targets
- Test for common web vulnerabilities (SQLi, XSS, CSRF, etc.)
- Analyze authentication and authorization mechanisms
- Check for misconfigurations and exposures
- Generate detailed findings with severity ratings
- Create comprehensive penetration testing reports

Each agent operates autonomously and performs thorough black-box testing.

Use this tool AFTER reviewing attack surface results to test high-value targets.
You can spawn multiple agents in parallel - they will run concurrently.`,
    inputSchema: z.object({
      targets: z
        .array(
          z.object({
            target: z
              .string()
              .describe("The target to pentest (URL, IP, or domain)"),
            objective: z
              .string()
              .describe(
                "Specific penetration testing objective for this target"
              ),
          })
        )
        .describe(
          "Array of targets to pentest (recommended: 3-10 high-priority targets)"
        ),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ targets }) => {
      try {
        console.log(
          `[Orchestrator] Spawning ${targets.length} pentest agents...`
        );

        // Launch all pentest agents in parallel
        const promises = targets.map(async (targetInfo) => {
          try {
            const result = runPentestAgent({
              target: targetInfo.target,
              objective: targetInfo.objective,
              model,
              abortSignal,
            });

            // Consume the stream
            for await (const _delta of result.fullStream) {
              // Stream is consumed
            }

            return {
              target: targetInfo.target,
              success: true,
              sessionId: result.session.id,
              sessionPath: result.session.rootPath,
            };
          } catch (error: any) {
            return {
              target: targetInfo.target,
              success: false,
              error: error.message,
            };
          }
        });

        const results = await Promise.all(promises);
        const successful = results.filter((r) => r.success).length;
        const failed = results.filter((r) => !r.success).length;

        return {
          success: true,
          totalAgents: targets.length,
          successful,
          failed,
          results,
          message: `Launched ${
            targets.length
          } pentest agents. ${successful} completed successfully${
            failed > 0 ? `, ${failed} failed` : ""
          }.`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to spawn pentest agents: ${error.message}`,
        };
      }
    },
  });

  // Tool to read attack surface results
  const readAttackSurfaceResults = tool({
    name: "read_attack_surface_results",
    description: `Read the structured results from a completed attack surface analysis.
    
Use this after running get_attack_surface to review:
- Complete asset inventory
- High-value targets with objectives
- Key findings and exposures
- Recommended testing priorities

This helps you decide which targets to send to pentest agents.`,
    inputSchema: z.object({
      sessionPath: z
        .string()
        .describe("Path to the attack surface agent session"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({ sessionPath }) => {
      try {
        const resultsPath = join(sessionPath, "attack-surface-results.json");

        if (!existsSync(resultsPath)) {
          return {
            success: false,
            error: "Results file not found",
            message: `No results file found at ${resultsPath}`,
          };
        }

        const resultsData = readFileSync(resultsPath, "utf-8");
        const results: AttackSurfaceAnalysisResults = JSON.parse(resultsData);

        return {
          success: true,
          results,
          message: `Loaded attack surface results: ${results.summary.totalAssets} assets, ${results.summary.highValueTargets} high-value targets`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to read results: ${error.message}`,
        };
      }
    },
  });

  // Tool to generate final orchestration report
  const generateFinalReport = tool({
    name: "generate_final_report",
    description: `Generate the final comprehensive report for the entire thorough penetration test.
    
This creates a master report that combines:
- Attack surface analysis findings
- All pentest agent findings
- Overall risk assessment
- Prioritized recommendations
- Executive summary

Use this as the FINAL step after all agents have completed.`,
    inputSchema: z.object({
      executiveSummary: z
        .string()
        .describe("High-level executive summary of the entire engagement"),
      attackSurfaceSessionPath: z
        .string()
        .describe("Path to attack surface agent session"),
      pentestSessionPaths: z
        .array(z.string())
        .describe("Paths to all pentest agent sessions"),
      overallRiskAssessment: z
        .string()
        .describe("Overall risk assessment across all targets"),
      keyFindings: z
        .array(z.string())
        .describe("Most critical findings across all agents"),
      recommendations: z
        .string()
        .describe("Comprehensive recommendations for remediation"),
      toolCallDescription: z
        .string()
        .describe("Concise description of this tool call"),
    }),
    execute: async ({
      executiveSummary,
      attackSurfaceSessionPath,
      pentestSessionPaths,
      overallRiskAssessment,
      keyFindings,
      recommendations,
    }) => {
      try {
        // This would aggregate all reports - simplified for now
        const report = `# Comprehensive Penetration Testing Report

**Session ID:** ${session.id}
**Target:** ${session.target}
**Objective:** ${session.objective}

## Executive Summary

${executiveSummary}

## Overall Risk Assessment

${overallRiskAssessment}

## Key Findings

${keyFindings.map((finding, idx) => `${idx + 1}. ${finding}`).join("\n")}

## Recommendations

${recommendations}

## Sub-Agent Sessions

### Attack Surface Analysis
- Session: ${attackSurfaceSessionPath}

### Penetration Testing Sessions
${pentestSessionPaths.map((path, idx) => `${idx + 1}. ${path}`).join("\n")}

---

*This report aggregates findings from ${
          pentestSessionPaths.length + 1
        } autonomous security testing agents.*
`;

        const reportPath = join(
          session.rootPath,
          "comprehensive-pentest-report.md"
        );
        require("fs").writeFileSync(reportPath, report);

        return {
          success: true,
          reportPath,
          message: `Comprehensive report generated at ${reportPath}`,
        };
      } catch (error: any) {
        return {
          success: false,
          error: error.message,
          message: `Failed to generate report: ${error.message}`,
        };
      }
    },
  });

  return {
    get_attack_surface: getAttackSurface,
    run_pentest_agents: runPentestAgents,
    read_attack_surface_results: readAttackSurfaceResults,
    generate_final_report: generateFinalReport,
  };
}
